<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building a Tetris AI: Heuristic Evaluation and Search Strategies | w732</title><meta name=keywords content="AI,Games,Algorithms,JavaScript,Machine Learning"><meta name=description content="This article provides a comprehensive technical deep-dive into building an AI for Tetris. We&rsquo;ll cover the fundamental mechanics of modern Tetris, the heuristic evaluation approach, and how to combine multiple features into an effective AI player.
Table of Contents

Tetris Fundamentals
AI Architecture Overview
Heuristic Features
Search Algorithm
Weight Tuning
Advanced Techniques
Implementation Details


Tetris Fundamentals
Before diving into AI strategies, let&rsquo;s understand the core mechanics of modern Tetris (specifically the Tetris Guideline standard)."><meta name=author content="w732"><link rel=canonical href=https://w732.github.io/posts/tetris-ai-technical/><link crossorigin=anonymous href=/assets/css/stylesheet.a29c24210eb31d9ce56f669c66a35c9c51b17376b7764e336a49af7dec914cf0.css integrity="sha256-opwkIQ6zHZzlb2acZqNcnFGxc3a3dk4zakmvfeyRTPA=" rel="preload stylesheet" as=style><link rel=icon href=https://w732.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://w732.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://w732.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://w732.github.io/apple-touch-icon.png><link rel=mask-icon href=https://w732.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://w732.github.io/posts/tetris-ai-technical/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://w732.github.io/posts/tetris-ai-technical/"><meta property="og:site_name" content="w732"><meta property="og:title" content="Building a Tetris AI: Heuristic Evaluation and Search Strategies"><meta property="og:description" content="This article provides a comprehensive technical deep-dive into building an AI for Tetris. We’ll cover the fundamental mechanics of modern Tetris, the heuristic evaluation approach, and how to combine multiple features into an effective AI player.
Table of Contents Tetris Fundamentals AI Architecture Overview Heuristic Features Search Algorithm Weight Tuning Advanced Techniques Implementation Details Tetris Fundamentals Before diving into AI strategies, let’s understand the core mechanics of modern Tetris (specifically the Tetris Guideline standard)."><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-23T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-23T00:00:00+00:00"><meta property="article:tag" content="AI"><meta property="article:tag" content="Games"><meta property="article:tag" content="Algorithms"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="Machine Learning"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building a Tetris AI: Heuristic Evaluation and Search Strategies"><meta name=twitter:description content="This article provides a comprehensive technical deep-dive into building an AI for Tetris. We&rsquo;ll cover the fundamental mechanics of modern Tetris, the heuristic evaluation approach, and how to combine multiple features into an effective AI player.
Table of Contents

Tetris Fundamentals
AI Architecture Overview
Heuristic Features
Search Algorithm
Weight Tuning
Advanced Techniques
Implementation Details


Tetris Fundamentals
Before diving into AI strategies, let&rsquo;s understand the core mechanics of modern Tetris (specifically the Tetris Guideline standard)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://w732.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Building a Tetris AI: Heuristic Evaluation and Search Strategies","item":"https://w732.github.io/posts/tetris-ai-technical/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building a Tetris AI: Heuristic Evaluation and Search Strategies","name":"Building a Tetris AI: Heuristic Evaluation and Search Strategies","description":"This article provides a comprehensive technical deep-dive into building an AI for Tetris. We\u0026rsquo;ll cover the fundamental mechanics of modern Tetris, the heuristic evaluation approach, and how to combine multiple features into an effective AI player.\nTable of Contents Tetris Fundamentals AI Architecture Overview Heuristic Features Search Algorithm Weight Tuning Advanced Techniques Implementation Details Tetris Fundamentals Before diving into AI strategies, let\u0026rsquo;s understand the core mechanics of modern Tetris (specifically the Tetris Guideline standard).\n","keywords":["AI","Games","Algorithms","JavaScript","Machine Learning"],"articleBody":"This article provides a comprehensive technical deep-dive into building an AI for Tetris. We’ll cover the fundamental mechanics of modern Tetris, the heuristic evaluation approach, and how to combine multiple features into an effective AI player.\nTable of Contents Tetris Fundamentals AI Architecture Overview Heuristic Features Search Algorithm Weight Tuning Advanced Techniques Implementation Details Tetris Fundamentals Before diving into AI strategies, let’s understand the core mechanics of modern Tetris (specifically the Tetris Guideline standard).\nThe Seven Tetrominoes Tetris uses exactly seven distinct pieces, each made of four connected squares:\nI-piece: ████ J-piece: █ L-piece: █ ███ ███ O-piece: ██ S-piece: ██ T-piece: █ ██ ██ ███ Z-piece: ██ ██ Each piece has a unique color and rotation behavior.\n7-Bag Randomizer Modern Tetris doesn’t use pure random piece generation. Instead, it uses the 7-Bag system:\nTake all 7 tetrominoes and put them in a “bag” Shuffle the bag randomly Deal pieces one by one from the bag When the bag is empty, refill with all 7 pieces and shuffle again This guarantees:\nYou’ll never wait more than 12 pieces for any specific tetromino The worst drought for any piece is 12 (end of one bag + start of next) More predictable gameplay compared to pure random // 7-Bag implementation Preview.prototype.gen = function() { var pieceList = [0, 1, 2, 3, 4, 5, 6]; return pieceList.sort(function() { return 0.5 - Math.random(); }); }; Super Rotation System (SRS) The Super Rotation System is the standard rotation system for modern Tetris. It defines:\nBasic Rotation: How pieces rotate around their center Wall Kicks: Alternative positions when basic rotation fails Basic Rotation Pieces rotate around a center point. For a clockwise rotation:\nfunction rotateTetroClockwise(tetro) { const size = tetro.length; const rotated = []; for (let i = 0; i \u003c size; i++) { rotated[i] = []; for (let row = size - 1; row \u003e= 0; row--) { rotated[i][row] = tetro[row][size - 1 - i]; } } return rotated; } Wall Kicks When a piece can’t rotate in place (blocked by wall or other pieces), the game tries alternative positions called wall kicks. Each piece has a kick table defining offsets to try:\n// Standard wall kick data for J, L, S, T, Z pieces const kickData = [ [[0,0], [-1,0], [-1,-1], [0,2], [-1,2]], // State 0 [[0,0], [1,0], [1,1], [0,-2], [1,-2]], // State 1 [[0,0], [1,0], [1,-1], [0,2], [1,2]], // State 2 [[0,0], [-1,0], [-1,1], [0,-2], [-1,-2]] // State 3 ]; The rotation algorithm:\nTry basic rotation at current position If blocked, try each offset in the kick table Use first valid position found If all fail, rotation doesn’t happen Hold System Players can “hold” the current piece for later use:\nPress hold to swap current piece with held piece If no held piece, current piece goes to hold and next piece spawns Can only hold once per piece (prevents infinite stalling) Preview Queue Modern Tetris shows upcoming pieces (typically 5-6). This is crucial for AI planning.\nLock Delay When a piece lands, there’s a brief delay before it locks. During this time:\nPlayer can still move/rotate the piece Moving resets the lock delay (up to a limit) This enables advanced techniques like T-Spins AI Architecture Overview Our Tetris AI uses a heuristic evaluation approach:\n┌─────────────────────────────────────────────────────────┐ │ AI Decision Loop │ ├─────────────────────────────────────────────────────────┤ │ 1. Generate all possible placements │ │ - 4 rotations × ~12 X positions ≈ 48 placements │ │ │ │ 2. For each placement: │ │ - Simulate piece placement │ │ - Calculate heuristic features │ │ - Compute weighted score │ │ │ │ 3. Select placement with highest score │ │ │ │ 4. Execute moves (rotate, shift, drop) │ └─────────────────────────────────────────────────────────┘ The key insight is that we don’t need to simulate future games or use complex tree search. A well-tuned heuristic evaluation of the immediate board state is surprisingly effective.\nHeuristic Features The AI evaluates board states using 10 features. Each captures a different aspect of “board quality.”\n1. Landing Height What it measures: How high the piece lands on the stack.\nWhy it matters: Lower placements are generally better. High placements indicate danger (close to game over).\nfunction calculateLandingHeight(landingY, tetro) { let minY = GRID_HEIGHT, maxY = 0; for (let dx = 0; dx \u003c tetro.length; dx++) { for (let dy = 0; dy \u003c tetro[dx].length; dy++) { if (tetro[dx][dy]) { const actualY = landingY + dy; if (actualY \u003c minY) minY = actualY; if (actualY \u003e maxY) maxY = actualY; } } } // Return height from bottom (higher = worse) return GRID_HEIGHT - (minY + maxY) / 2; } Typical weight: -1.0 (negative = prefer lower)\n2. Rows Cleared What it measures: Number of complete lines cleared by this placement.\nWhy it matters: Clearing lines is the primary goal. More clears = better.\nfunction calculateRowsCleared(grid) { let lines = 0; for (let y = 0; y \u003c GRID_HEIGHT; y++) { let full = true; for (let x = 0; x \u003c GRID_WIDTH; x++) { if (!grid[x][y]) { full = false; break; } } if (full) lines++; } return lines; } Typical weight: +3.0 (positive = reward clearing)\n3. Row Transitions What it measures: Number of horizontal transitions between filled and empty cells.\nWhy it matters: High transitions indicate a “jagged” surface that’s hard to clear. Smooth rows are easier to complete.\nLow transitions (good): High transitions (bad): ██████████ █ █ █ █ █ ██████████ █ █ █ █ █ function calculateRowTransitions(grid) { let transitions = 0; for (let y = 0; y \u003c GRID_HEIGHT; y++) { let prev = 1; // Treat border as filled for (let x = 0; x \u003c GRID_WIDTH; x++) { const current = grid[x][y] ? 1 : 0; if (current !== prev) transitions++; prev = current; } if (prev === 0) transitions++; // Right border } return transitions; } Typical weight: -0.5\n4. Column Transitions What it measures: Number of vertical transitions in each column.\nWhy it matters: Vertical transitions often indicate holes or overhangs—both problematic.\nfunction calculateColumnTransitions(grid) { let transitions = 0; for (let x = 0; x \u003c GRID_WIDTH; x++) { let prev = 1; // Treat top as filled for (let y = 0; y \u003c GRID_HEIGHT; y++) { const current = grid[x][y] ? 1 : 0; if (current !== prev) transitions++; prev = current; } } return transitions; } Typical weight: -0.5\n5. Holes What it measures: Empty cells with at least one filled cell above them.\nWhy it matters: Holes are devastating—they waste space and require clearing multiple lines above to fix.\nHole example: ███ ███ ███○███ ← The ○ is a hole ████████ function calculateHoles(grid) { let holes = 0; for (let x = 0; x \u003c GRID_WIDTH; x++) { let blockFound = false; for (let y = 0; y \u003c GRID_HEIGHT; y++) { if (grid[x][y]) { blockFound = true; } else if (blockFound) { holes++; } } } return holes; } Typical weight: -4.0 (heavily penalized)\n6. Well Sums What it measures: Depth of “wells”—single-column gaps bounded by filled cells on both sides.\nWhy it matters: Deep wells are problematic because only I-pieces can fill them efficiently. Wells of depth \u003e 4 are particularly bad.\nWell example: ███ ███ ███ ███ ← This is a well of depth 3 ███ ███ █████████ function calculateWellSums(grid) { let wellSums = 0; // Check each column for wells for (let x = 0; x \u003c GRID_WIDTH; x++) { for (let y = 0; y \u003c GRID_HEIGHT; y++) { // Check if this is a well cell const leftBlocked = (x === 0) || grid[x-1][y]; const rightBlocked = (x === GRID_WIDTH-1) || grid[x+1][y]; if (!grid[x][y] \u0026\u0026 leftBlocked \u0026\u0026 rightBlocked) { // Count well depth let depth = 1; while (y + depth \u003c GRID_HEIGHT \u0026\u0026 !grid[x][y + depth]) { depth++; } wellSums += depth; } } } return wellSums; } Typical weight: -0.5\n7. Bumpiness What it measures: Sum of absolute height differences between adjacent columns.\nWhy it matters: A flat surface is easier to build on and clear. Bumpy surfaces create dependencies and awkward placements.\nLow bumpiness (good): High bumpiness (bad): █ █ ███ █ █ █████ ██ ██ ███████ ███ ███ function calculateBumpiness(grid) { const heights = calculateColumnHeights(grid); let bumpiness = 0; for (let i = 0; i \u003c heights.length - 1; i++) { bumpiness += Math.abs(heights[i] - heights[i + 1]); } return bumpiness; } function calculateColumnHeights(grid) { const heights = []; for (let x = 0; x \u003c GRID_WIDTH; x++) { let h = 0; for (let y = 0; y \u003c GRID_HEIGHT; y++) { if (grid[x][y]) { h = GRID_HEIGHT - y; break; } } heights.push(h); } return heights; } Typical weight: -0.5\n8. Hole Depth What it measures: Maximum depth of holes in each column (how many blocks above each hole).\nWhy it matters: Shallow holes (1-2 blocks above) are recoverable. Deep holes (5+ blocks) are nearly permanent damage.\nfunction calculateHoleDepth(grid) { let totalDepth = 0; for (let x = 0; x \u003c GRID_WIDTH; x++) { let blocksAboveHole = 0; let inHole = false; for (let y = 0; y \u003c GRID_HEIGHT; y++) { if (grid[x][y]) { if (inHole) { // Still in hole, don't reset counter } else { blocksAboveHole++; } } else { // Empty cell if (blocksAboveHole \u003e 0) { // This is a hole inHole = true; totalDepth += blocksAboveHole; } } } } return totalDepth; } Typical weight: -1.0\n9. Aggregate Height What it measures: Sum of all column heights.\nWhy it matters: Lower overall stack = more room to maneuver = safer. High stacks risk game over.\nfunction calculateAggregateHeight(grid) { const heights = calculateColumnHeights(grid); return heights.reduce((sum, h) =\u003e sum + h, 0); } Typical weight: -0.5\n10. Covered Cells What it measures: Number of filled cells directly above holes.\nWhy it matters: More covered cells = more work to clear the hole. This penalizes “burying” holes deep.\nfunction calculateCoveredCells(grid) { let covered = 0; for (let x = 0; x \u003c GRID_WIDTH; x++) { let holeFound = false; // Scan from bottom to find holes for (let y = GRID_HEIGHT - 1; y \u003e= 0; y--) { if (!grid[x][y]) { // Check if there's a block above for (let yAbove = y - 1; yAbove \u003e= 0; yAbove--) { if (grid[x][yAbove]) { holeFound = true; break; } } if (holeFound) { // Count all blocks above this hole for (let yAbove = y - 1; yAbove \u003e= 0; yAbove--) { if (grid[x][yAbove]) covered++; } break; } } } } return covered; } Typical weight: -1.0\nSearch Algorithm Basic Search The simplest approach: evaluate all possible placements and pick the best.\nPiece.prototype.getBestMove = function() { const grid = stack.grid; let bestScore = -Infinity; let bestMove = null; // Try all 4 rotations const rotations = getAllRotations(this.tetro); for (let r = 0; r \u003c rotations.length; r++) { const rotatedTetro = rotations[r]; // Try all X positions for (let x = -2; x \u003c GRID_WIDTH; x++) { // Find landing Y (drop simulation) let y = 0; while (this.moveValidSim(x, y + 1, rotatedTetro, grid)) { y++; } // Skip invalid positions if (!this.moveValidSim(x, y, rotatedTetro, grid)) continue; // Simulate and evaluate const result = aiSimulate(grid, rotatedTetro, x, y); const score = aiEvaluate(result.grid, y, rotatedTetro); if (score \u003e bestScore) { bestScore = score; bestMove = { x, y, rotation: r, tetro: rotatedTetro }; } } } return bestMove; }; Lookahead Search Considering the next piece significantly improves play quality:\nPiece.prototype.getBestMoveWithLookahead = function(nextPieceIndex) { const grid = stack.grid; let bestScore = -Infinity; let bestMove = null; const nextTetro = pieces[nextPieceIndex].tetro; const DISCOUNT = 0.5; // Weight for future evaluation // For each possible placement of current piece for (const placement of getAllPlacements(this.tetro, grid)) { // Simulate current placement const result = aiSimulate(grid, placement.tetro, placement.x, placement.y); let score = aiEvaluate(result.grid, placement.y, placement.tetro); // Find best placement for next piece on resulting board const nextBest = findBestPlacement(nextTetro, result.grid); if (nextBest.score \u003e -Infinity) { score += DISCOUNT * nextBest.score; } if (score \u003e bestScore) { bestScore = score; bestMove = placement; } } return bestMove; }; The discount factor (0.5) balances immediate vs. future gains. Too high makes the AI overly speculative; too low ignores valuable lookahead.\nEarly Pruning Skip obviously bad placements to improve performance:\nfunction quickHoleCount(grid, tetro, x, y) { let newHoles = 0; for (let dx = 0; dx \u003c tetro.length; dx++) { for (let dy = 0; dy \u003c tetro[dx].length; dy++) { if (tetro[dx][dy]) { const gx = x + dx; const gy = y + dy; // Count empty cells below this mino for (let below = gy + 1; below \u003c GRID_HEIGHT; below++) { if (!grid[gx][below]) newHoles++; else break; } } } } return newHoles; } // In search loop: if (quickHoleCount(grid, tetro, x, y) \u003e 3) { continue; // Skip this placement } Weight Tuning The Evaluation Function The final score is a weighted sum:\nfunction aiEvaluate(grid, landingY, tetro) { const w = window.AI_WEIGHTS; return ( w.landingHeight * calculateLandingHeight(landingY, tetro) + w.rowsCleared * calculateRowsCleared(grid) + w.rowTransitions * calculateRowTransitions(grid) + w.columnTransitions * calculateColumnTransitions(grid) + w.holes * calculateHoles(grid) + w.wellSums * calculateWellSums(grid) + w.bumpiness * calculateBumpiness(grid) + w.holeDepth * calculateHoleDepth(grid) + w.aggregateHeight * calculateAggregateHeight(grid) + w.coveredCells * calculateCoveredCells(grid) ); } Weight Presets Different weight combinations produce different play styles:\nBalanced (Default) { landingHeight: -1, rowsCleared: 3, rowTransitions: -0.5, columnTransitions: -0.5, holes: -4, wellSums: -0.5, bumpiness: -0.5, holeDepth: -1, aggregateHeight: -0.5, coveredCells: -1 } Conservative (Safe Play) Heavily penalizes holes and height. Prefers stable, low stacks.\n{ landingHeight: -1.5, rowsCleared: 2, // Less reward for clears holes: -6, // Heavily penalize holes bumpiness: -1, // Prefer flat surface aggregateHeight: -0.8, // Keep stack low coveredCells: -2 // Avoid burying holes } Aggressive (High Score) Prioritizes line clears, accepts some risk.\n{ landingHeight: -0.5, // Accept higher placements rowsCleared: 4, // Reward clears highly holes: -3, // More tolerant of holes bumpiness: -0.3, // Accept bumpy surfaces aggregateHeight: -0.3 // Allow higher stacks } Tuning Methods Manual Tuning: Play with weights, observe behavior, adjust Genetic Algorithms: Evolve weights over many games Gradient-Based: Measure performance, compute gradients, optimize Cross-Entropy Method: Sample weight vectors, keep best performers Advanced Techniques Hold Decision Should the AI use the hold piece?\nPiece.prototype.shouldUseHold = function() { if (this.held) return false; // Already used hold const currentScore = evaluateBestPlacement(this.tetro, grid); const holdPiece = (hold.piece !== undefined) ? pieces[hold.piece].tetro : pieces[preview.grabBag[0]].tetro; const holdScore = evaluateBestPlacement(holdPiece, grid); // Use hold if significantly better return holdScore \u003e currentScore + 0.5; }; T-Spin Detection T-Spins award bonus points. Detecting them:\nfunction isTSpin(piece, grid) { if (piece.index !== 5) return false; // Not T-piece // Check 4 corners of T-piece center const cx = piece.x + 1; const cy = piece.y + 1; const corners = [ [cx-1, cy-1], [cx+1, cy-1], [cx-1, cy+1], [cx+1, cy+1] ]; let filledCorners = 0; for (const [x, y] of corners) { if (x \u003c 0 || x \u003e= 10 || y \u003e= 22 || grid[x][y]) { filledCorners++; } } return filledCorners \u003e= 3; } Combo Tracking Consecutive line clears multiply score:\nlet comboCount = 0; function onLineClear(linesCleared) { if (linesCleared \u003e 0) { comboCount++; score += linesCleared * 100 * comboCount; } else { comboCount = 0; } } Implementation Details Performance Optimizations Rotation Deduplication: Some pieces look identical after rotation (O-piece has 1 unique rotation, I/S/Z have 2). Use hashing to skip duplicates: function tetroHash(tetro) { let hash = 0; for (let x = 0; x \u003c tetro.length; x++) { for (let y = 0; y \u003c tetro[x].length; y++) { hash = (hash \u003c\u003c 1) | (tetro[x][y] ? 1 : 0); } } return hash; } Column Height Caching: Calculate once, reuse for multiple features: function aiEvaluate(grid, landingY, tetro) { const heights = calculateColumnHeights(grid); // Calculate once const bumpiness = calculateBumpiness(grid, heights); // Reuse const aggregateHeight = calculateAggregateHeight(grid, heights); // Reuse // ... } Incremental Updates: Instead of recalculating entire board, update only affected columns. Animation System For human-watchable play, animate moves step by step:\nconst animateStep = () =\u003e { // Step 1: Rotations first if (currentRotations \u003c targetRotations) { piece.rotate(1); currentRotations++; setTimeout(animateStep, MOVE_DELAY); return; } // Step 2: Horizontal movement if (piece.x \u003c targetX) { piece.x += 1; setTimeout(animateStep, MOVE_DELAY); return; } else if (piece.x \u003e targetX) { piece.x -= 1; setTimeout(animateStep, MOVE_DELAY); return; } // Step 3: Drop if (useHardDrop) { piece.hardDrop(); } else { softDropStep(); } }; Ghost Piece Show where the AI plans to place the piece:\nwindow.AI_PLANNED_MOVE = { x: targetX, y: targetY, tetro: rotatedTetro }; Piece.prototype.drawGhost = function() { if (window.aiEnabled \u0026\u0026 window.AI_PLANNED_MOVE) { const plan = window.AI_PLANNED_MOVE; ctx.globalAlpha = 0.3; draw(plan.tetro, plan.x, plan.y, ctx); ctx.globalAlpha = 1; } }; Conclusion Building a Tetris AI demonstrates several important AI concepts:\nFeature Engineering: Identifying what makes a “good” board state Heuristic Search: Finding good solutions without exhaustive search Weight Tuning: Balancing multiple objectives Lookahead: Planning beyond immediate moves The heuristic approach is elegant in its simplicity—no neural networks, no massive training datasets. Just careful analysis of what makes Tetris positions good or bad.\nFor further improvement, consider:\nDeeper lookahead (3+ pieces) Monte Carlo Tree Search for difficult situations Learning weights through self-play Incorporating T-Spin and combo strategies Play the AI | View Source Code\n","wordCount":"2855","inLanguage":"en","datePublished":"2026-01-23T00:00:00Z","dateModified":"2026-01-23T00:00:00Z","author":{"@type":"Person","name":"w732"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://w732.github.io/posts/tetris-ai-technical/"},"publisher":{"@type":"Organization","name":"w732","logo":{"@type":"ImageObject","url":"https://w732.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://w732.github.io/ accesskey=h title="w732 (Alt + H)">w732</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Building a Tetris AI: Heuristic Evaluation and Search Strategies</h1><div class=post-meta><span title='2026-01-23 00:00:00 +0000 UTC'>January 23, 2026</span>&nbsp;·&nbsp;<span>14 min</span>&nbsp;·&nbsp;<span>w732</span></div></header><div class=post-content><p>This article provides a comprehensive technical deep-dive into building an AI for Tetris. We&rsquo;ll cover the fundamental mechanics of modern Tetris, the heuristic evaluation approach, and how to combine multiple features into an effective AI player.</p><h2 id=table-of-contents>Table of Contents<a hidden class=anchor aria-hidden=true href=#table-of-contents>#</a></h2><ol><li><a href=#tetris-fundamentals>Tetris Fundamentals</a></li><li><a href=#ai-architecture-overview>AI Architecture Overview</a></li><li><a href=#heuristic-features>Heuristic Features</a></li><li><a href=#search-algorithm>Search Algorithm</a></li><li><a href=#weight-tuning>Weight Tuning</a></li><li><a href=#advanced-techniques>Advanced Techniques</a></li><li><a href=#implementation-details>Implementation Details</a></li></ol><hr><h2 id=tetris-fundamentals>Tetris Fundamentals<a hidden class=anchor aria-hidden=true href=#tetris-fundamentals>#</a></h2><p>Before diving into AI strategies, let&rsquo;s understand the core mechanics of modern Tetris (specifically the Tetris Guideline standard).</p><h3 id=the-seven-tetrominoes>The Seven Tetrominoes<a hidden class=anchor aria-hidden=true href=#the-seven-tetrominoes>#</a></h3><p>Tetris uses exactly seven distinct pieces, each made of four connected squares:</p><pre tabindex=0><code>I-piece:  ████      J-piece:  █        L-piece:    █
                              ███                ███

O-piece:  ██        S-piece:   ██      T-piece:   █
          ██                  ██                 ███

Z-piece:  ██
           ██
</code></pre><p>Each piece has a unique color and rotation behavior.</p><h3 id=7-bag-randomizer>7-Bag Randomizer<a hidden class=anchor aria-hidden=true href=#7-bag-randomizer>#</a></h3><p>Modern Tetris doesn&rsquo;t use pure random piece generation. Instead, it uses the <strong>7-Bag system</strong>:</p><ol><li>Take all 7 tetrominoes and put them in a &ldquo;bag&rdquo;</li><li>Shuffle the bag randomly</li><li>Deal pieces one by one from the bag</li><li>When the bag is empty, refill with all 7 pieces and shuffle again</li></ol><p>This guarantees:</p><ul><li>You&rsquo;ll never wait more than 12 pieces for any specific tetromino</li><li>The worst drought for any piece is 12 (end of one bag + start of next)</li><li>More predictable gameplay compared to pure random</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// 7-Bag implementation
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>Preview</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>gen</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>pieceList</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>pieceList</span>.<span style=color:#a6e22e>sort</span>(<span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>-</span> Math.<span style=color:#a6e22e>random</span>();
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=super-rotation-system-srs>Super Rotation System (SRS)<a hidden class=anchor aria-hidden=true href=#super-rotation-system-srs>#</a></h3><p>The <strong>Super Rotation System</strong> is the standard rotation system for modern Tetris. It defines:</p><ol><li><strong>Basic Rotation</strong>: How pieces rotate around their center</li><li><strong>Wall Kicks</strong>: Alternative positions when basic rotation fails</li></ol><h4 id=basic-rotation>Basic Rotation<a hidden class=anchor aria-hidden=true href=#basic-rotation>#</a></h4><p>Pieces rotate around a center point. For a clockwise rotation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>rotateTetroClockwise</span>(<span style=color:#a6e22e>tetro</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>size</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tetro</span>.<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rotated</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>size</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>rotated</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>row</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>size</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>row</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>row</span><span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>rotated</span>[<span style=color:#a6e22e>i</span>][<span style=color:#a6e22e>row</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>tetro</span>[<span style=color:#a6e22e>row</span>][<span style=color:#a6e22e>size</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>i</span>];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rotated</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=wall-kicks>Wall Kicks<a hidden class=anchor aria-hidden=true href=#wall-kicks>#</a></h4><p>When a piece can&rsquo;t rotate in place (blocked by wall or other pieces), the game tries alternative positions called <strong>wall kicks</strong>. Each piece has a kick table defining offsets to try:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#75715e>// Standard wall kick data for J, L, S, T, Z pieces
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>kickData</span> <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    [[<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>], [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>], [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>2</span>], [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>]],   <span style=color:#75715e>// State 0
</span></span></span><span style=display:flex><span>    [[<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>], [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>], [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>0</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>], [<span style=color:#ae81ff>1</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>]],     <span style=color:#75715e>// State 1
</span></span></span><span style=display:flex><span>    [[<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>], [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>], [<span style=color:#ae81ff>1</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>2</span>], [<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>]],      <span style=color:#75715e>// State 2
</span></span></span><span style=display:flex><span>    [[<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>], [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>], [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>], [<span style=color:#ae81ff>0</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>], [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>]]   <span style=color:#75715e>// State 3
</span></span></span><span style=display:flex><span>];
</span></span></code></pre></div><p>The rotation algorithm:</p><ol><li>Try basic rotation at current position</li><li>If blocked, try each offset in the kick table</li><li>Use first valid position found</li><li>If all fail, rotation doesn&rsquo;t happen</li></ol><h3 id=hold-system>Hold System<a hidden class=anchor aria-hidden=true href=#hold-system>#</a></h3><p>Players can &ldquo;hold&rdquo; the current piece for later use:</p><ul><li>Press hold to swap current piece with held piece</li><li>If no held piece, current piece goes to hold and next piece spawns</li><li>Can only hold once per piece (prevents infinite stalling)</li></ul><h3 id=preview-queue>Preview Queue<a hidden class=anchor aria-hidden=true href=#preview-queue>#</a></h3><p>Modern Tetris shows upcoming pieces (typically 5-6). This is crucial for AI planning.</p><h3 id=lock-delay>Lock Delay<a hidden class=anchor aria-hidden=true href=#lock-delay>#</a></h3><p>When a piece lands, there&rsquo;s a brief delay before it locks. During this time:</p><ul><li>Player can still move/rotate the piece</li><li>Moving resets the lock delay (up to a limit)</li><li>This enables advanced techniques like T-Spins</li></ul><hr><h2 id=ai-architecture-overview>AI Architecture Overview<a hidden class=anchor aria-hidden=true href=#ai-architecture-overview>#</a></h2><p>Our Tetris AI uses a <strong>heuristic evaluation</strong> approach:</p><pre tabindex=0><code>┌─────────────────────────────────────────────────────────┐
│                    AI Decision Loop                      │
├─────────────────────────────────────────────────────────┤
│  1. Generate all possible placements                     │
│     - 4 rotations × ~12 X positions ≈ 48 placements     │
│                                                          │
│  2. For each placement:                                  │
│     - Simulate piece placement                           │
│     - Calculate heuristic features                       │
│     - Compute weighted score                             │
│                                                          │
│  3. Select placement with highest score                  │
│                                                          │
│  4. Execute moves (rotate, shift, drop)                  │
└─────────────────────────────────────────────────────────┘
</code></pre><p>The key insight is that we don&rsquo;t need to simulate future games or use complex tree search. A well-tuned heuristic evaluation of the immediate board state is surprisingly effective.</p><hr><h2 id=heuristic-features>Heuristic Features<a hidden class=anchor aria-hidden=true href=#heuristic-features>#</a></h2><p>The AI evaluates board states using 10 features. Each captures a different aspect of &ldquo;board quality.&rdquo;</p><h3 id=1-landing-height>1. Landing Height<a hidden class=anchor aria-hidden=true href=#1-landing-height>#</a></h3><p><strong>What it measures</strong>: How high the piece lands on the stack.</p><p><strong>Why it matters</strong>: Lower placements are generally better. High placements indicate danger (close to game over).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calculateLandingHeight</span>(<span style=color:#a6e22e>landingY</span>, <span style=color:#a6e22e>tetro</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>minY</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>GRID_HEIGHT</span>, <span style=color:#a6e22e>maxY</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>dx</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>dx</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>tetro</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>dx</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>dy</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>dy</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>tetro</span>[<span style=color:#a6e22e>dx</span>].<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>dy</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>tetro</span>[<span style=color:#a6e22e>dx</span>][<span style=color:#a6e22e>dy</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>actualY</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>landingY</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>dy</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>actualY</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>minY</span>) <span style=color:#a6e22e>minY</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>actualY</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>actualY</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>maxY</span>) <span style=color:#a6e22e>maxY</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>actualY</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Return height from bottom (higher = worse)
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>GRID_HEIGHT</span> <span style=color:#f92672>-</span> (<span style=color:#a6e22e>minY</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>maxY</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Typical weight</strong>: -1.0 (negative = prefer lower)</p><h3 id=2-rows-cleared>2. Rows Cleared<a hidden class=anchor aria-hidden=true href=#2-rows-cleared>#</a></h3><p><strong>What it measures</strong>: Number of complete lines cleared by this placement.</p><p><strong>Why it matters</strong>: Clearing lines is the primary goal. More clears = better.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calculateRowsCleared</span>(<span style=color:#a6e22e>grid</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>lines</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_HEIGHT</span>; <span style=color:#a6e22e>y</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>full</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_WIDTH</span>; <span style=color:#a6e22e>x</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span>][<span style=color:#a6e22e>y</span>]) { <span style=color:#a6e22e>full</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>; <span style=color:#66d9ef>break</span>; }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>full</span>) <span style=color:#a6e22e>lines</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lines</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Typical weight</strong>: +3.0 (positive = reward clearing)</p><h3 id=3-row-transitions>3. Row Transitions<a hidden class=anchor aria-hidden=true href=#3-row-transitions>#</a></h3><p><strong>What it measures</strong>: Number of horizontal transitions between filled and empty cells.</p><p><strong>Why it matters</strong>: High transitions indicate a &ldquo;jagged&rdquo; surface that&rsquo;s hard to clear. Smooth rows are easier to complete.</p><pre tabindex=0><code>Low transitions (good):    High transitions (bad):
██████████                 █ █ █ █ █
██████████                 █ █ █ █ █
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calculateRowTransitions</span>(<span style=color:#a6e22e>grid</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>transitions</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_HEIGHT</span>; <span style=color:#a6e22e>y</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// Treat border as filled
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_WIDTH</span>; <span style=color:#a6e22e>x</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>current</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span>][<span style=color:#a6e22e>y</span>] <span style=color:#f92672>?</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>current</span> <span style=color:#f92672>!==</span> <span style=color:#a6e22e>prev</span>) <span style=color:#a6e22e>transitions</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>current</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>prev</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>) <span style=color:#a6e22e>transitions</span><span style=color:#f92672>++</span>; <span style=color:#75715e>// Right border
</span></span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>transitions</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Typical weight</strong>: -0.5</p><h3 id=4-column-transitions>4. Column Transitions<a hidden class=anchor aria-hidden=true href=#4-column-transitions>#</a></h3><p><strong>What it measures</strong>: Number of vertical transitions in each column.</p><p><strong>Why it matters</strong>: Vertical transitions often indicate holes or overhangs—both problematic.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calculateColumnTransitions</span>(<span style=color:#a6e22e>grid</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>transitions</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_WIDTH</span>; <span style=color:#a6e22e>x</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// Treat top as filled
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_HEIGHT</span>; <span style=color:#a6e22e>y</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>current</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span>][<span style=color:#a6e22e>y</span>] <span style=color:#f92672>?</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>current</span> <span style=color:#f92672>!==</span> <span style=color:#a6e22e>prev</span>) <span style=color:#a6e22e>transitions</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>current</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>transitions</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Typical weight</strong>: -0.5</p><h3 id=5-holes>5. Holes<a hidden class=anchor aria-hidden=true href=#5-holes>#</a></h3><p><strong>What it measures</strong>: Empty cells with at least one filled cell above them.</p><p><strong>Why it matters</strong>: Holes are devastating—they waste space and require clearing multiple lines above to fix.</p><pre tabindex=0><code>Hole example:
  ███ ███
  ███○███   ← The ○ is a hole
  ████████
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calculateHoles</span>(<span style=color:#a6e22e>grid</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>holes</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_WIDTH</span>; <span style=color:#a6e22e>x</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>blockFound</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_HEIGHT</span>; <span style=color:#a6e22e>y</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span>][<span style=color:#a6e22e>y</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>blockFound</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>blockFound</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>holes</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>holes</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Typical weight</strong>: -4.0 (heavily penalized)</p><h3 id=6-well-sums>6. Well Sums<a hidden class=anchor aria-hidden=true href=#6-well-sums>#</a></h3><p><strong>What it measures</strong>: Depth of &ldquo;wells&rdquo;—single-column gaps bounded by filled cells on both sides.</p><p><strong>Why it matters</strong>: Deep wells are problematic because only I-pieces can fill them efficiently. Wells of depth > 4 are particularly bad.</p><pre tabindex=0><code>Well example:
  ███ ███
  ███ ███   ← This is a well of depth 3
  ███ ███
  █████████
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calculateWellSums</span>(<span style=color:#a6e22e>grid</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>wellSums</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Check each column for wells
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_WIDTH</span>; <span style=color:#a6e22e>x</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_HEIGHT</span>; <span style=color:#a6e22e>y</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Check if this is a well cell
</span></span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>leftBlocked</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>x</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][<span style=color:#a6e22e>y</span>];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rightBlocked</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>x</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>GRID_WIDTH</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][<span style=color:#a6e22e>y</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span>][<span style=color:#a6e22e>y</span>] <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>leftBlocked</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>rightBlocked</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Count well depth
</span></span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>depth</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>y</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>depth</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_HEIGHT</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span>][<span style=color:#a6e22e>y</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>depth</span>]) {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>depth</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>wellSums</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>depth</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>wellSums</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Typical weight</strong>: -0.5</p><h3 id=7-bumpiness>7. Bumpiness<a hidden class=anchor aria-hidden=true href=#7-bumpiness>#</a></h3><p><strong>What it measures</strong>: Sum of absolute height differences between adjacent columns.</p><p><strong>Why it matters</strong>: A flat surface is easier to build on and clear. Bumpy surfaces create dependencies and awkward placements.</p><pre tabindex=0><code>Low bumpiness (good):      High bumpiness (bad):
    █                         █
   ███                        █ █
  █████                      ██ ██
 ███████                    ███ ███
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calculateBumpiness</span>(<span style=color:#a6e22e>grid</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>heights</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>calculateColumnHeights</span>(<span style=color:#a6e22e>grid</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>bumpiness</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>heights</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>bumpiness</span> <span style=color:#f92672>+=</span> Math.<span style=color:#a6e22e>abs</span>(<span style=color:#a6e22e>heights</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>-</span> <span style=color:#a6e22e>heights</span>[<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>bumpiness</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calculateColumnHeights</span>(<span style=color:#a6e22e>grid</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>heights</span> <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_WIDTH</span>; <span style=color:#a6e22e>x</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_HEIGHT</span>; <span style=color:#a6e22e>y</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span>][<span style=color:#a6e22e>y</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>h</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>GRID_HEIGHT</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>y</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>heights</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>h</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>heights</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Typical weight</strong>: -0.5</p><h3 id=8-hole-depth>8. Hole Depth<a hidden class=anchor aria-hidden=true href=#8-hole-depth>#</a></h3><p><strong>What it measures</strong>: Maximum depth of holes in each column (how many blocks above each hole).</p><p><strong>Why it matters</strong>: Shallow holes (1-2 blocks above) are recoverable. Deep holes (5+ blocks) are nearly permanent damage.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calculateHoleDepth</span>(<span style=color:#a6e22e>grid</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>totalDepth</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_WIDTH</span>; <span style=color:#a6e22e>x</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>blocksAboveHole</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>inHole</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_HEIGHT</span>; <span style=color:#a6e22e>y</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span>][<span style=color:#a6e22e>y</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>inHole</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Still in hole, don&#39;t reset counter
</span></span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>blocksAboveHole</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Empty cell
</span></span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>blocksAboveHole</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// This is a hole
</span></span></span><span style=display:flex><span>                    <span style=color:#a6e22e>inHole</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>totalDepth</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>blocksAboveHole</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>totalDepth</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Typical weight</strong>: -1.0</p><h3 id=9-aggregate-height>9. Aggregate Height<a hidden class=anchor aria-hidden=true href=#9-aggregate-height>#</a></h3><p><strong>What it measures</strong>: Sum of all column heights.</p><p><strong>Why it matters</strong>: Lower overall stack = more room to maneuver = safer. High stacks risk game over.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calculateAggregateHeight</span>(<span style=color:#a6e22e>grid</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>heights</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>calculateColumnHeights</span>(<span style=color:#a6e22e>grid</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>heights</span>.<span style=color:#a6e22e>reduce</span>((<span style=color:#a6e22e>sum</span>, <span style=color:#a6e22e>h</span>) =&gt; <span style=color:#a6e22e>sum</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>h</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Typical weight</strong>: -0.5</p><h3 id=10-covered-cells>10. Covered Cells<a hidden class=anchor aria-hidden=true href=#10-covered-cells>#</a></h3><p><strong>What it measures</strong>: Number of filled cells directly above holes.</p><p><strong>Why it matters</strong>: More covered cells = more work to clear the hole. This penalizes &ldquo;burying&rdquo; holes deep.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>calculateCoveredCells</span>(<span style=color:#a6e22e>grid</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>covered</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_WIDTH</span>; <span style=color:#a6e22e>x</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>holeFound</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Scan from bottom to find holes
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>GRID_HEIGHT</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>y</span><span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span>][<span style=color:#a6e22e>y</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Check if there&#39;s a block above
</span></span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>yAbove</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>yAbove</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>yAbove</span><span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span>][<span style=color:#a6e22e>yAbove</span>]) {
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>holeFound</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>holeFound</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Count all blocks above this hole
</span></span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>yAbove</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>yAbove</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>yAbove</span><span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span>][<span style=color:#a6e22e>yAbove</span>]) <span style=color:#a6e22e>covered</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>covered</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Typical weight</strong>: -1.0</p><hr><h2 id=search-algorithm>Search Algorithm<a hidden class=anchor aria-hidden=true href=#search-algorithm>#</a></h2><h3 id=basic-search>Basic Search<a hidden class=anchor aria-hidden=true href=#basic-search>#</a></h3><p>The simplest approach: evaluate all possible placements and pick the best.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>Piece</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>getBestMove</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>grid</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>grid</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>bestScore</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#66d9ef>Infinity</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>bestMove</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Try all 4 rotations
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rotations</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getAllRotations</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tetro</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>r</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>rotations</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>r</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rotatedTetro</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>rotations</span>[<span style=color:#a6e22e>r</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Try all X positions
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_WIDTH</span>; <span style=color:#a6e22e>x</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Find landing Y (drop simulation)
</span></span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>moveValidSim</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>rotatedTetro</span>, <span style=color:#a6e22e>grid</span>)) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>y</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Skip invalid positions
</span></span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>moveValidSim</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>rotatedTetro</span>, <span style=color:#a6e22e>grid</span>)) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Simulate and evaluate
</span></span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>aiSimulate</span>(<span style=color:#a6e22e>grid</span>, <span style=color:#a6e22e>rotatedTetro</span>, <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>score</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>aiEvaluate</span>(<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>grid</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>rotatedTetro</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>score</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>bestScore</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>bestScore</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>score</span>;
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>bestMove</span> <span style=color:#f92672>=</span> { <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>rotation</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>tetro</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>rotatedTetro</span> };
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>bestMove</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=lookahead-search>Lookahead Search<a hidden class=anchor aria-hidden=true href=#lookahead-search>#</a></h3><p>Considering the next piece significantly improves play quality:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>Piece</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>getBestMoveWithLookahead</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>nextPieceIndex</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>grid</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>grid</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>bestScore</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#66d9ef>Infinity</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>bestMove</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>nextTetro</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>pieces</span>[<span style=color:#a6e22e>nextPieceIndex</span>].<span style=color:#a6e22e>tetro</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>DISCOUNT</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.5</span>; <span style=color:#75715e>// Weight for future evaluation
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For each possible placement of current piece
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>placement</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>getAllPlacements</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tetro</span>, <span style=color:#a6e22e>grid</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Simulate current placement
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>aiSimulate</span>(<span style=color:#a6e22e>grid</span>, <span style=color:#a6e22e>placement</span>.<span style=color:#a6e22e>tetro</span>, <span style=color:#a6e22e>placement</span>.<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>placement</span>.<span style=color:#a6e22e>y</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>score</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>aiEvaluate</span>(<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>grid</span>, <span style=color:#a6e22e>placement</span>.<span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>placement</span>.<span style=color:#a6e22e>tetro</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Find best placement for next piece on resulting board
</span></span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>nextBest</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>findBestPlacement</span>(<span style=color:#a6e22e>nextTetro</span>, <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>grid</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>nextBest</span>.<span style=color:#a6e22e>score</span> <span style=color:#f92672>&gt;</span> <span style=color:#f92672>-</span><span style=color:#66d9ef>Infinity</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>score</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>DISCOUNT</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>nextBest</span>.<span style=color:#a6e22e>score</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>score</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>bestScore</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>bestScore</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>score</span>;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>bestMove</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>placement</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>bestMove</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The discount factor (0.5) balances immediate vs. future gains. Too high makes the AI overly speculative; too low ignores valuable lookahead.</p><h3 id=early-pruning>Early Pruning<a hidden class=anchor aria-hidden=true href=#early-pruning>#</a></h3><p>Skip obviously bad placements to improve performance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>quickHoleCount</span>(<span style=color:#a6e22e>grid</span>, <span style=color:#a6e22e>tetro</span>, <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>newHoles</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>dx</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>dx</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>tetro</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>dx</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>dy</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>dy</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>tetro</span>[<span style=color:#a6e22e>dx</span>].<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>dy</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>tetro</span>[<span style=color:#a6e22e>dx</span>][<span style=color:#a6e22e>dy</span>]) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>gx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>dx</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>gy</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>dy</span>;
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Count empty cells below this mino
</span></span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>below</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>gy</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>below</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>GRID_HEIGHT</span>; <span style=color:#a6e22e>below</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>gx</span>][<span style=color:#a6e22e>below</span>]) <span style=color:#a6e22e>newHoles</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newHoles</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// In search loop:
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>quickHoleCount</span>(<span style=color:#a6e22e>grid</span>, <span style=color:#a6e22e>tetro</span>, <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>; <span style=color:#75715e>// Skip this placement
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=weight-tuning>Weight Tuning<a hidden class=anchor aria-hidden=true href=#weight-tuning>#</a></h2><h3 id=the-evaluation-function>The Evaluation Function<a hidden class=anchor aria-hidden=true href=#the-evaluation-function>#</a></h3><p>The final score is a weighted sum:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>aiEvaluate</span>(<span style=color:#a6e22e>grid</span>, <span style=color:#a6e22e>landingY</span>, <span style=color:#a6e22e>tetro</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>w</span> <span style=color:#f92672>=</span> window.<span style=color:#a6e22e>AI_WEIGHTS</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>landingHeight</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>calculateLandingHeight</span>(<span style=color:#a6e22e>landingY</span>, <span style=color:#a6e22e>tetro</span>) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>rowsCleared</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>calculateRowsCleared</span>(<span style=color:#a6e22e>grid</span>) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>rowTransitions</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>calculateRowTransitions</span>(<span style=color:#a6e22e>grid</span>) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>columnTransitions</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>calculateColumnTransitions</span>(<span style=color:#a6e22e>grid</span>) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>holes</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>calculateHoles</span>(<span style=color:#a6e22e>grid</span>) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>wellSums</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>calculateWellSums</span>(<span style=color:#a6e22e>grid</span>) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>bumpiness</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>calculateBumpiness</span>(<span style=color:#a6e22e>grid</span>) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>holeDepth</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>calculateHoleDepth</span>(<span style=color:#a6e22e>grid</span>) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>aggregateHeight</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>calculateAggregateHeight</span>(<span style=color:#a6e22e>grid</span>) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>coveredCells</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>calculateCoveredCells</span>(<span style=color:#a6e22e>grid</span>)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=weight-presets>Weight Presets<a hidden class=anchor aria-hidden=true href=#weight-presets>#</a></h3><p>Different weight combinations produce different play styles:</p><h4 id=balanced-default>Balanced (Default)<a hidden class=anchor aria-hidden=true href=#balanced-default>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>landingHeight</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rowsCleared</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rowTransitions</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>columnTransitions</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>holes</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>wellSums</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bumpiness</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>holeDepth</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>aggregateHeight</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>coveredCells</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=conservative-safe-play>Conservative (Safe Play)<a hidden class=anchor aria-hidden=true href=#conservative-safe-play>#</a></h4><p>Heavily penalizes holes and height. Prefers stable, low stacks.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>landingHeight</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1.5</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rowsCleared</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>,        <span style=color:#75715e>// Less reward for clears
</span></span></span><span style=display:flex><span>    <span style=color:#a6e22e>holes</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>6</span>,             <span style=color:#75715e>// Heavily penalize holes
</span></span></span><span style=display:flex><span>    <span style=color:#a6e22e>bumpiness</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,         <span style=color:#75715e>// Prefer flat surface
</span></span></span><span style=display:flex><span>    <span style=color:#a6e22e>aggregateHeight</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0.8</span>, <span style=color:#75715e>// Keep stack low
</span></span></span><span style=display:flex><span>    <span style=color:#a6e22e>coveredCells</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>       <span style=color:#75715e>// Avoid burying holes
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=aggressive-high-score>Aggressive (High Score)<a hidden class=anchor aria-hidden=true href=#aggressive-high-score>#</a></h4><p>Prioritizes line clears, accepts some risk.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>landingHeight</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0.5</span>,   <span style=color:#75715e>// Accept higher placements
</span></span></span><span style=display:flex><span>    <span style=color:#a6e22e>rowsCleared</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>4</span>,        <span style=color:#75715e>// Reward clears highly
</span></span></span><span style=display:flex><span>    <span style=color:#a6e22e>holes</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>,             <span style=color:#75715e>// More tolerant of holes
</span></span></span><span style=display:flex><span>    <span style=color:#a6e22e>bumpiness</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0.3</span>,       <span style=color:#75715e>// Accept bumpy surfaces
</span></span></span><span style=display:flex><span>    <span style=color:#a6e22e>aggregateHeight</span><span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>0.3</span>  <span style=color:#75715e>// Allow higher stacks
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=tuning-methods>Tuning Methods<a hidden class=anchor aria-hidden=true href=#tuning-methods>#</a></h3><ol><li><strong>Manual Tuning</strong>: Play with weights, observe behavior, adjust</li><li><strong>Genetic Algorithms</strong>: Evolve weights over many games</li><li><strong>Gradient-Based</strong>: Measure performance, compute gradients, optimize</li><li><strong>Cross-Entropy Method</strong>: Sample weight vectors, keep best performers</li></ol><hr><h2 id=advanced-techniques>Advanced Techniques<a hidden class=anchor aria-hidden=true href=#advanced-techniques>#</a></h2><h3 id=hold-decision>Hold Decision<a hidden class=anchor aria-hidden=true href=#hold-decision>#</a></h3><p>Should the AI use the hold piece?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>Piece</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>shouldUseHold</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>held</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// Already used hold
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>currentScore</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>evaluateBestPlacement</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tetro</span>, <span style=color:#a6e22e>grid</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>holdPiece</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>hold</span>.<span style=color:#a6e22e>piece</span> <span style=color:#f92672>!==</span> <span style=color:#66d9ef>undefined</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>?</span> <span style=color:#a6e22e>pieces</span>[<span style=color:#a6e22e>hold</span>.<span style=color:#a6e22e>piece</span>].<span style=color:#a6e22e>tetro</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> <span style=color:#a6e22e>pieces</span>[<span style=color:#a6e22e>preview</span>.<span style=color:#a6e22e>grabBag</span>[<span style=color:#ae81ff>0</span>]].<span style=color:#a6e22e>tetro</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>holdScore</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>evaluateBestPlacement</span>(<span style=color:#a6e22e>holdPiece</span>, <span style=color:#a6e22e>grid</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Use hold if significantly better
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>holdScore</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>currentScore</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=t-spin-detection>T-Spin Detection<a hidden class=anchor aria-hidden=true href=#t-spin-detection>#</a></h3><p>T-Spins award bonus points. Detecting them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>isTSpin</span>(<span style=color:#a6e22e>piece</span>, <span style=color:#a6e22e>grid</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>piece</span>.<span style=color:#a6e22e>index</span> <span style=color:#f92672>!==</span> <span style=color:#ae81ff>5</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// Not T-piece
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Check 4 corners of T-piece center
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>cx</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>piece</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>cy</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>piece</span>.<span style=color:#a6e22e>y</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>corners</span> <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>cx</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>cy</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>], [<span style=color:#a6e22e>cx</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>cy</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>cx</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>cy</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>], [<span style=color:#a6e22e>cx</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>cy</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    ];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>filledCorners</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>] <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>corners</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>22</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>grid</span>[<span style=color:#a6e22e>x</span>][<span style=color:#a6e22e>y</span>]) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>filledCorners</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>filledCorners</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=combo-tracking>Combo Tracking<a hidden class=anchor aria-hidden=true href=#combo-tracking>#</a></h3><p>Consecutive line clears multiply score:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>comboCount</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>onLineClear</span>(<span style=color:#a6e22e>linesCleared</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>linesCleared</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>comboCount</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>score</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>linesCleared</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>100</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>comboCount</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>comboCount</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=implementation-details>Implementation Details<a hidden class=anchor aria-hidden=true href=#implementation-details>#</a></h2><h3 id=performance-optimizations>Performance Optimizations<a hidden class=anchor aria-hidden=true href=#performance-optimizations>#</a></h3><ol><li><strong>Rotation Deduplication</strong>: Some pieces look identical after rotation (O-piece has 1 unique rotation, I/S/Z have 2). Use hashing to skip duplicates:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>tetroHash</span>(<span style=color:#a6e22e>tetro</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>tetro</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>x</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>y</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>tetro</span>[<span style=color:#a6e22e>x</span>].<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>y</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>hash</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>hash</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>|</span> (<span style=color:#a6e22e>tetro</span>[<span style=color:#a6e22e>x</span>][<span style=color:#a6e22e>y</span>] <span style=color:#f92672>?</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>hash</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li><strong>Column Height Caching</strong>: Calculate once, reuse for multiple features:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>aiEvaluate</span>(<span style=color:#a6e22e>grid</span>, <span style=color:#a6e22e>landingY</span>, <span style=color:#a6e22e>tetro</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>heights</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>calculateColumnHeights</span>(<span style=color:#a6e22e>grid</span>); <span style=color:#75715e>// Calculate once
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>bumpiness</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>calculateBumpiness</span>(<span style=color:#a6e22e>grid</span>, <span style=color:#a6e22e>heights</span>);     <span style=color:#75715e>// Reuse
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>aggregateHeight</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>calculateAggregateHeight</span>(<span style=color:#a6e22e>grid</span>, <span style=color:#a6e22e>heights</span>); <span style=color:#75715e>// Reuse
</span></span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li><strong>Incremental Updates</strong>: Instead of recalculating entire board, update only affected columns.</li></ol><h3 id=animation-system>Animation System<a hidden class=anchor aria-hidden=true href=#animation-system>#</a></h3><p>For human-watchable play, animate moves step by step:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>animateStep</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Step 1: Rotations first
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>currentRotations</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>targetRotations</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>piece</span>.<span style=color:#a6e22e>rotate</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>currentRotations</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>setTimeout</span>(<span style=color:#a6e22e>animateStep</span>, <span style=color:#a6e22e>MOVE_DELAY</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Step 2: Horizontal movement
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>piece</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>targetX</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>piece</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>setTimeout</span>(<span style=color:#a6e22e>animateStep</span>, <span style=color:#a6e22e>MOVE_DELAY</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>piece</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>targetX</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>piece</span>.<span style=color:#a6e22e>x</span> <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>setTimeout</span>(<span style=color:#a6e22e>animateStep</span>, <span style=color:#a6e22e>MOVE_DELAY</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Step 3: Drop
</span></span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>useHardDrop</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>piece</span>.<span style=color:#a6e22e>hardDrop</span>();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>softDropStep</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=ghost-piece>Ghost Piece<a hidden class=anchor aria-hidden=true href=#ghost-piece>#</a></h3><p>Show where the AI plans to place the piece:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>window.<span style=color:#a6e22e>AI_PLANNED_MOVE</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>x</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>targetX</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>y</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>targetY</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>tetro</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>rotatedTetro</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Piece</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>drawGhost</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (window.<span style=color:#a6e22e>aiEnabled</span> <span style=color:#f92672>&amp;&amp;</span> window.<span style=color:#a6e22e>AI_PLANNED_MOVE</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>plan</span> <span style=color:#f92672>=</span> window.<span style=color:#a6e22e>AI_PLANNED_MOVE</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>globalAlpha</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.3</span>;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>draw</span>(<span style=color:#a6e22e>plan</span>.<span style=color:#a6e22e>tetro</span>, <span style=color:#a6e22e>plan</span>.<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>plan</span>.<span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>ctx</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>globalAlpha</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><hr><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Building a Tetris AI demonstrates several important AI concepts:</p><ol><li><strong>Feature Engineering</strong>: Identifying what makes a &ldquo;good&rdquo; board state</li><li><strong>Heuristic Search</strong>: Finding good solutions without exhaustive search</li><li><strong>Weight Tuning</strong>: Balancing multiple objectives</li><li><strong>Lookahead</strong>: Planning beyond immediate moves</li></ol><p>The heuristic approach is elegant in its simplicity—no neural networks, no massive training datasets. Just careful analysis of what makes Tetris positions good or bad.</p><p>For further improvement, consider:</p><ul><li>Deeper lookahead (3+ pieces)</li><li>Monte Carlo Tree Search for difficult situations</li><li>Learning weights through self-play</li><li>Incorporating T-Spin and combo strategies</li></ul><p><strong><a href=/games/tetris-ai/index.html>Play the AI</a></strong> | <strong><a href=https://github.com/w732/w732.github.io/tree/main/static/games/tetris-ai>View Source Code</a></strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://w732.github.io/tags/ai/>AI</a></li><li><a href=https://w732.github.io/tags/games/>Games</a></li><li><a href=https://w732.github.io/tags/algorithms/>Algorithms</a></li><li><a href=https://w732.github.io/tags/javascript/>JavaScript</a></li><li><a href=https://w732.github.io/tags/machine-learning/>Machine Learning</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://w732.github.io/>w732</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><div style=text-align:center;color:var(--secondary);font-size:14px;margin-top:10px>Visitors <span id=busuanzi_value_site_uv></span> | Views <span id=busuanzi_value_site_pv></span></div><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>