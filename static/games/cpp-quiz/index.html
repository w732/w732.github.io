<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>C++ Trivials Quiz Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex; justify-content: center; align-items: center; min-height: 100vh;
        }
        #game-container {
            user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
        }
        /* Desktop */
        @media (min-width: 769px) {
            #game-container {
                width: 800px; height: 650px; border-radius: 16px; overflow: hidden;
                box-shadow: 0 0 60px rgba(74, 158, 255, 0.3), 0 0 100px rgba(74, 158, 255, 0.1);
                border: 1px solid rgba(74, 158, 255, 0.2);
            }
            #game-container canvas { border-radius: 16px; }
        }
        /* Mobile */
        @media (max-width: 768px) {
            #game-container { width: 100vw; height: 100vh; }
        }
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a1a2e; display: flex; justify-content: center; align-items: center;
            z-index: 1000; color: #4a9eff; font-size: 20px;
        }
        .spinner {
            width: 40px; height: 40px; border: 3px solid rgba(74, 158, 255, 0.3);
            border-top-color: #4a9eff; border-radius: 50%;
            animation: spin 1s linear infinite; margin-right: 12px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loading"><div class="spinner"></div>Loading...</div>
    <div id="game-container"></div>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <script>
// Language system
let currentLang = 'en';

const UI_TEXT = {
    en: {
        subtitle: 'Quiz Game',
        info: '100 C++ Knowledge Points\nRandom 20 Questions Per Game',
        categories: ['Types & Expressions', 'Memory Management', 'STL Containers', 'Functions', 'C++11-20 Features', 'Templates', 'Common UB'],
        startGame: 'Start Game',
        score: 'Score',
        excellent: 'Excellent!',
        greatJob: 'Great Job!',
        goodTry: 'Good Try!',
        keepLearning: 'Keep Learning!',
        outOf: 'out of',
        correct: 'Correct',
        wrong: 'Wrong',
        again: 'Again',
        review: 'Review',
        back: 'Back',
        your: 'Your',
        answer: 'Answer',
        langBtn: '中文'
    },
    zh: {
        subtitle: '问答游戏',
        info: '100 道 C++ 知识点\n每局随机 20 题',
        categories: ['类型与表达式', '内存管理', 'STL 容器', '函数调用', 'C++11-20 特性', '模板系统', '常见 UB'],
        startGame: '开始游戏',
        score: '得分',
        excellent: '太棒了！',
        greatJob: '做得好！',
        goodTry: '继续加油！',
        keepLearning: '再接再厉！',
        outOf: '满分',
        correct: '正确',
        wrong: '错误',
        again: '再来',
        review: '回顾',
        back: '返回',
        your: '你的答案',
        answer: '正确答案',
        langBtn: 'EN'
    }
};

const allQuestions = [
    { id: 1, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "What is sizeof('a') in C++?", zh: "sizeof('a') 在 C++ 中是多少？" }, options: { en: ["1 (char type)", "4 (int type)", "2 (short type)", "Compiler dependent"], zh: ["1（char类型）", "4（int类型）", "2（short类型）", "取决于编译器"] }, correct: 0, explanation: { en: "In C it's int(4), in C++ it's char(1)", zh: "C中是int(4)，C++中是char(1)" } },
    { id: 2, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "Is char signed or unsigned by default?", zh: "char 默认是 signed 还是 unsigned？" }, options: { en: ["signed", "unsigned", "implementation-defined", "Always signed char"], zh: ["signed", "unsigned", "implementation-defined", "总是 signed char"] }, correct: 2, explanation: { en: "Implementation-defined, better to declare explicitly", zh: "implementation-defined，最好显式声明" } },
    { id: 3, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "What is the result of -1 < 1u?", zh: "-1 < 1u 的结果是什么？" }, options: { en: ["true", "false", "Compilation error", "Undefined behavior"], zh: ["true", "false", "编译错误", "未定义行为"] }, correct: 1, explanation: { en: "-1 converts to unsigned becoming a large positive number", zh: "-1 转成 unsigned 后变成极大正数" } },
    { id: 4, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "What is the result type of uint8_t + uint8_t?", zh: "uint8_t + uint8_t 的结果类型是？" }, options: { en: ["uint8_t", "uint16_t", "int (integer promotion)", "unsigned int"], zh: ["uint8_t", "uint16_t", "int（整型提升）", "unsigned int"] }, correct: 2, explanation: { en: "Integer promotion promotes small integer types to int", zh: "整型提升会将小整数类型提升为int" } },
    { id: 5, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "Before C++17, what is 1 << 31?", zh: "在C++17前，1 << 31 是什么行为？" }, options: { en: ["Equals INT_MIN", "Equals 0", "Undefined behavior (UB)", "Compilation error"], zh: ["等于 INT_MIN", "等于 0", "未定义行为(UB)", "编译错误"] }, correct: 2, explanation: { en: "Signed int left shift overflow is UB", zh: "signed int 左移溢出是UB" } },
    { id: 6, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "What is the result of 0.1 + 0.2 == 0.3?", zh: "0.1 + 0.2 == 0.3 的结果？" }, options: { en: ["true", "false", "Compilation error", "Compiler dependent"], zh: ["true", "false", "编译错误", "取决于编译器"] }, correct: 1, explanation: { en: "Floating-point precision issues cause inequality", zh: "浮点精度问题导致不相等" } },
    { id: 7, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "int a=1; a=a++ + ++a; result?", zh: "int a=1; a=a++ + ++a; 结果？" }, options: { en: ["4", "5", "3", "Undefined behavior (UB)"], zh: ["4", "5", "3", "未定义行为(UB)"] }, correct: 3, explanation: { en: "Multiple modifications without sequence point is UB", zh: "多次修改同一变量无序点是UB" } },
    { id: 8, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "What is the type of nullptr?", zh: "nullptr 的类型是什么？" }, options: { en: ["void*", "int", "std::nullptr_t", "NULL"], zh: ["void*", "int", "std::nullptr_t", "NULL"] }, correct: 2, explanation: { en: "std::nullptr_t, implicitly convertible to any pointer", zh: "std::nullptr_t，可隐式转换成任意指针" } },
    { id: 9, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "What is sizeof(bool)?", zh: "sizeof(bool) 的值是？" }, options: { en: ["Always 1", "Always 4", "implementation-defined", "Always 0"], zh: ["总是 1", "总是 4", "implementation-defined", "总是 0"] }, correct: 2, explanation: { en: "Implementation-defined, typically 1 byte", zh: "implementation-defined，通常是1字节" } },
    { id: 10, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "0xFFFFFFFF in signed 32-bit int is?", zh: "0xFFFFFFFF 在 signed 32位 int 中是？" }, options: { en: ["4294967295", "-1", "0", "Overflow error"], zh: ["4294967295", "-1", "0", "溢出错误"] }, correct: 1, explanation: { en: "Signed is -1; unsigned is 4294967295", zh: "signed是-1；unsigned是4294967295" } },
    { id: 11, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "What is true + true?", zh: "true + true 的结果？" }, options: { en: ["true", "2", "Compilation error", "Undefined behavior"], zh: ["true", "2", "编译错误", "未定义行为"] }, correct: 1, explanation: { en: "Bool in arithmetic, true promotes to 1", zh: "布尔值参与整数运算，true被提升为1" } },
    { id: 12, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "signed char c = 255; what is c?", zh: "signed char c = 255; c的值是？" }, options: { en: ["255", "-1", "0", "Undefined behavior"], zh: ["255", "-1", "0", "未定义行为"] }, correct: 1, explanation: { en: "signed char range is -128 to 127, overflow becomes -1", zh: "signed char范围是-128到127，溢出变-1" } },
    { id: 13, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "Difference between int* p = 0 and nullptr?", zh: "int* p = 0 与 nullptr 的区别？" }, options: { en: ["Different functionality", "nullptr is type-safe", "0 is faster", "No difference"], zh: ["功能不同", "nullptr类型安全", "0更快", "没有区别"] }, correct: 1, explanation: { en: "nullptr is type-safe, won't be confused with integer", zh: "nullptr类型安全，不会被误解为整数" } },
    { id: 14, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "auto x = {1, 2}; what is x's type?", zh: "auto x = {1, 2}; x 的类型？" }, options: { en: ["int[]", "vector<int>", "initializer_list<int>", "array<int,2>"], zh: ["int[]", "vector<int>", "initializer_list<int>", "array<int,2>"] }, correct: 2, explanation: { en: "Brace initialization deduces to initializer_list", zh: "花括号初始化推导为initializer_list" } },
    { id: 15, category: { en: "Basic Types", zh: "基础类型" }, question: { en: "What does const int* p mean?", zh: "const int* p 表示什么？" }, options: { en: ["Pointer is const", "Pointed object is const", "Both are const", "Syntax error"], zh: ["指针是常量", "被指对象是常量", "两者都是常量", "语法错误"] }, correct: 1, explanation: { en: "const modifies left side → pointed object is const", zh: "const修饰左边→被指向对象const" } },
    { id: 16, category: { en: "Memory", zh: "内存管理" }, question: { en: "Main difference between malloc and new?", zh: "malloc 和 new 的主要区别？" }, options: { en: ["No difference", "malloc doesn't call constructor", "new doesn't allocate memory", "malloc is faster"], zh: ["没有区别", "malloc不调构造函数", "new不分配内存", "malloc更快"] }, correct: 1, explanation: { en: "malloc only allocates memory without calling constructor", zh: "malloc只分配内存不调用构造函数" } },
    { id: 17, category: { en: "Memory", zh: "内存管理" }, question: { en: "new[] allocated, using delete to free?", zh: "new[] 分配，用 delete 释放？" }, options: { en: ["Normal release", "Undefined behavior (UB)", "Compilation error", "Only frees first"], zh: ["正常释放", "未定义行为(UB)", "编译错误", "只释放第一个"] }, correct: 1, explanation: { en: "delete and delete[] must match", zh: "delete和delete[]必须匹配" } },
    { id: 18, category: { en: "Memory", zh: "内存管理" }, question: { en: "What happens when returning reference to local?", zh: "返回局部变量的引用会怎样？" }, options: { en: ["Works normally", "Compilation error", "Undefined behavior (UB)", "Returns copy"], zh: ["正常工作", "编译错误", "未定义行为(UB)", "返回副本"] }, correct: 2, explanation: { en: "Stack is released after function return, it's UB", zh: "函数返回后栈空间释放，是UB" } },
    { id: 19, category: { en: "Memory", zh: "内存管理" }, question: { en: "What does placement new do?", zh: "placement new 的作用？" }, options: { en: ["Allocates more memory", "Constructs on existing memory", "Auto-releases memory", "Creates multiple objects"], zh: ["分配更大内存", "在已分配内存上构造", "自动释放内存", "创建多个对象"] }, correct: 1, explanation: { en: "Constructs object on already allocated memory", zh: "在已分配的内存上构造对象" } },
    { id: 20, category: { en: "Memory", zh: "内存管理" }, question: { en: "memset to initialize std::string?", zh: "memset 初始化 std::string？" }, options: { en: ["Works normally", "Undefined behavior (UB)", "Compilation error", "String becomes empty"], zh: ["正常工作", "未定义行为(UB)", "编译错误", "字符串变空"] }, correct: 1, explanation: { en: "memset only works on trivial objects", zh: "memset只能用在trivial对象上" } },
    { id: 21, category: { en: "Memory", zh: "内存管理" }, question: { en: "Size of empty class (class Empty{};)?", zh: "空类(class Empty{};)大小？" }, options: { en: ["0", "1", "4", "8"], zh: ["0", "1", "4", "8"] }, correct: 1, explanation: { en: "1 byte, ensures each object has unique address", zh: "1字节，保证每个对象地址不同" } },
    { id: 22, category: { en: "Memory", zh: "内存管理" }, question: { en: "Destructor call order?", zh: "析构函数调用顺序？" }, options: { en: ["Base → Derived", "Derived → Base", "Called simultaneously", "Only derived"], zh: ["基类→派生类", "派生类→基类", "同时调用", "只调用派生类"] }, correct: 1, explanation: { en: "Destruction order is Derived → Base", zh: "析构顺序是派生类→基类" } },
    { id: 23, category: { en: "Memory", zh: "内存管理" }, question: { en: "Static object destruction order across TUs?", zh: "不同翻译单元静态对象销毁顺序？" }, options: { en: ["Declaration order", "Alphabetical order", "Unspecified", "Simultaneous"], zh: ["按声明顺序", "按字母顺序", "不确定", "同时销毁"] }, correct: 2, explanation: { en: "Order across translation units is unspecified", zh: "不同翻译单元顺序不确定" } },
    { id: 24, category: { en: "Memory", zh: "内存管理" }, question: { en: "Does volatile guarantee thread safety?", zh: "volatile 能保证线程安全吗？" }, options: { en: ["Yes", "No", "On some platforms", "Compiler dependent"], zh: ["能", "不能", "部分平台能", "取决于编译器"] }, correct: 1, explanation: { en: "volatile only prevents optimization, not thread-safe", zh: "volatile只禁止优化，不保证线程安全" } },
    { id: 25, category: { en: "Memory", zh: "内存管理" }, question: { en: "Accessing after delete is what?", zh: "delete后再访问是什么行为？" }, options: { en: ["Returns default", "Undefined behavior (UB)", "Throws exception", "Returns NULL"], zh: ["返回默认值", "未定义行为(UB)", "抛出异常", "返回NULL"] }, correct: 1, explanation: { en: "use-after-free is undefined behavior", zh: "use-after-free是未定义行为" } },
    { id: 26, category: { en: "Memory", zh: "内存管理" }, question: { en: "What is a dangling reference?", zh: "什么是悬垂引用？" }, options: { en: ["Null reference", "Reference to freed object", "const reference", "Temporary reference"], zh: ["空引用", "引用已释放对象", "const引用", "临时引用"] }, correct: 1, explanation: { en: "Reference bound to freed object → dangling reference", zh: "引用绑定已释放对象→悬垂引用" } },
    { id: 27, category: { en: "Memory", zh: "内存管理" }, question: { en: "Which is correct about references?", zh: "关于引用，哪项正确？" }, options: { en: ["Can be uninitialized", "Must be initialized", "Can be rebound", "Can be null"], zh: ["可以不初始化", "必须初始化", "可以重新绑定", "可以为null"] }, correct: 1, explanation: { en: "References must be initialized at declaration", zh: "引用必须在声明时初始化" } },
    { id: 28, category: { en: "Memory", zh: "内存管理" }, question: { en: "Advantage of move semantics?", zh: "移动语义的优势？" }, options: { en: ["Safer", "Steals resources avoiding copy", "Cleaner code", "Better compatibility"], zh: ["更安全", "窃取资源避免拷贝", "代码更简洁", "兼容性更好"] }, correct: 1, explanation: { en: "Move semantics avoids unnecessary deep copies", zh: "移动语义避免不必要的深拷贝" } },
    { id: 29, category: { en: "Memory", zh: "内存管理" }, question: { en: "Copy constructor vs copy assignment?", zh: "拷贝构造和拷贝赋值的区别？" }, options: { en: ["No difference", "New object vs assign existing", "One uses = one uses ()", "Different efficiency"], zh: ["没有区别", "构造新对象vs赋值已有", "一个用=一个用()", "效率不同"] }, correct: 1, explanation: { en: "Copy ctor creates new, assignment assigns to existing", zh: "拷贝构造创建新对象，拷贝赋值给已存在对象" } },
    { id: 30, category: { en: "Memory", zh: "内存管理" }, question: { en: "Difference between T t; and T t{};?", zh: "T t; 和 T t{}; 的区别？" }, options: { en: ["No difference", "default vs value initialization", "Syntactic sugar", "Compiler optimization"], zh: ["没有区别", "default vs value初始化", "语法糖", "编译器优化"] }, correct: 1, explanation: { en: "T t; is default, T t{}; is value initialization", zh: "T t;是default，T t{};是value初始化" } },
    { id: 31, category: { en: "STL", zh: "STL容器" }, question: { en: "What does vector push_back invalidate?", zh: "vector push_back 会失效什么？" }, options: { en: ["Only iterator", "iterator/pointer/reference all may", "Nothing invalidated", "Only reference"], zh: ["只有iterator", "iterator/pointer/reference都可能", "不会失效", "只有reference"] }, correct: 1, explanation: { en: "All may invalidate on reallocation", zh: "重新分配内存时全部可能失效" } },
    { id: 32, category: { en: "STL", zh: "STL容器" }, question: { en: "deque insert at ends, what invalidates?", zh: "deque 两端插入时什么失效？" }, options: { en: ["Nothing", "Iterator invalidates, reference doesn't", "All invalidate", "Only pointer"], zh: ["都不失效", "iterator失效，reference不失效", "全部失效", "只有pointer"] }, correct: 1, explanation: { en: "End insertion: Iterator invalid, Reference valid", zh: "两端插入时Iterator失效，Reference不失效" } },
    { id: 33, category: { en: "STL", zh: "STL容器" }, question: { en: "list insert, does iterator invalidate?", zh: "list 插入时迭代器是否失效？" }, options: { en: ["Yes", "No (except deleted node)", "Partial", "Depends on position"], zh: ["会失效", "不失效（除被删节点）", "部分失效", "取决于位置"] }, correct: 1, explanation: { en: "list is linked, insert doesn't affect other iterators", zh: "list是链表，插入不影响其他迭代器" } },
    { id: 34, category: { en: "STL", zh: "STL容器" }, question: { en: "map operator[] on non-existent key?", zh: "map operator[] 访问不存在key？" }, options: { en: ["Throws exception", "Returns default", "Inserts default", "Returns end()"], zh: ["抛出异常", "返回默认值", "插入默认值", "返回end()"] }, correct: 2, explanation: { en: "operator[] inserts a default-valued element", zh: "operator[]会插入一个默认值元素" } },
    { id: 35, category: { en: "STL", zh: "STL容器" }, question: { en: "Difference between map find and operator[]?", zh: "map find 和 operator[] 区别？" }, options: { en: ["No difference", "find doesn't insert, [] does", "find is faster", "[] is safer"], zh: ["没有区别", "find不插入，[]会插入", "find更快", "[]更安全"] }, correct: 1, explanation: { en: "find returns end() if not found, doesn't insert", zh: "find不存在返回end()，不插入" } },
    { id: 36, category: { en: "STL", zh: "STL容器" }, question: { en: "unordered_map iteration order?", zh: "unordered_map 迭代顺序？" }, options: { en: ["Sorted by key", "Insertion order", "Unstable/unspecified", "Hash order"], zh: ["按key排序", "按插入顺序", "不稳定/不确定", "按hash排序"] }, correct: 2, explanation: { en: "Hash-based, iteration order is unstable", zh: "基于哈希表，迭代顺序不稳定" } },
    { id: 37, category: { en: "STL", zh: "STL容器" }, question: { en: "Difference between reserve and resize?", zh: "vector reserve 和 resize 区别？" }, options: { en: ["No difference", "reserve changes capacity, resize changes size", "reserve is faster", "resize changes capacity"], zh: ["没有区别", "reserve改capacity，resize改size", "reserve更快", "resize改capacity"] }, correct: 1, explanation: { en: "reserve only changes capacity, resize changes size", zh: "reserve只改capacity，resize改size" } },
    { id: 38, category: { en: "STL", zh: "STL容器" }, question: { en: "What is string's SSO?", zh: "string 的 SSO 是什么？" }, options: { en: ["Compressed string", "Small string stored in object", "Cached string", "Delayed allocation"], zh: ["压缩字符串", "小字符串存对象内部", "缓存字符串", "延迟分配"] }, correct: 1, explanation: { en: "Small strings stored inside object, avoiding heap", zh: "小字符串存对象内部，避免堆分配" } },
    { id: 39, category: { en: "STL", zh: "STL容器" }, question: { en: "erase-remove idiom?", zh: "erase-remove 惯用法？" }, options: { en: ["v.remove(x)", "v.erase(remove(...), end())", "std::erase(v, x)", "v.erase(x)"], zh: ["v.remove(x)", "v.erase(remove(...), end())", "std::erase(v, x)", "v.erase(x)"] }, correct: 1, explanation: { en: "remove moves elements, erase actually deletes", zh: "remove移动元素，erase真正删除" } },
    { id: 40, category: { en: "STL", zh: "STL容器" }, question: { en: "vector insert in middle, iterators?", zh: "vector 中间插入，迭代器？" }, options: { en: ["Not invalidated", "All invalidated", "After insert point invalid", "Only end() invalid"], zh: ["不失效", "全部失效", "插入点之后失效", "只有end()失效"] }, correct: 2, explanation: { en: "Middle insert invalidates from insert point onward", zh: "中间插入导致插入点之后失效" } },
    { id: 41, category: { en: "STL", zh: "STL容器" }, question: { en: "std::array vs C array advantage?", zh: "std::array vs C数组优势？" }, options: { en: ["Variable size", "Supports STL algorithms, has size()", "Auto expansion", "Less memory"], zh: ["大小可变", "支持STL算法，有size()", "自动扩容", "更省内存"] }, correct: 1, explanation: { en: "array supports STL algorithms and iterators", zh: "array支持STL算法和迭代器" } },
    { id: 42, category: { en: "STL", zh: "STL容器" }, question: { en: "Time complexity of vector swap?", zh: "vector swap 的时间复杂度？" }, options: { en: ["O(n)", "O(1)", "O(log n)", "O(n^2)"], zh: ["O(n)", "O(1)", "O(log n)", "O(n^2)"] }, correct: 1, explanation: { en: "swap only exchanges internal pointers, O(1)", zh: "swap只交换内部指针，是O(1)" } },
    { id: 43, category: { en: "STL", zh: "STL容器" }, question: { en: "Can priority_queue elements be modified?", zh: "priority_queue 能直接修改元素？" }, options: { en: ["Yes", "No, need pop then re-push", "Only top", "Through iterator"], zh: ["能", "不能，需pop后重新push", "只能修改top", "可以通过迭代器"] }, correct: 1, explanation: { en: "No direct modification, need to extract and reinsert", zh: "不支持直接修改，需要取出后重新插入" } },
    { id: 44, category: { en: "STL", zh: "STL容器" }, question: { en: "stack.pop() return value?", zh: "stack.pop() 返回值？" }, options: { en: ["Top element", "void", "bool", "New top"], zh: ["栈顶元素", "void", "bool", "新的栈顶"] }, correct: 1, explanation: { en: "pop() returns void, use top() first to get value", zh: "pop()返回void，需先用top()获取" } },
    { id: 45, category: { en: "STL", zh: "STL容器" }, question: { en: "unordered_set erase returns?", zh: "unordered_set erase 返回？" }, options: { en: ["void", "Deleted element", "Next valid iterator", "bool"], zh: ["void", "被删除元素", "下一个有效iterator", "bool"] }, correct: 2, explanation: { en: "erase returns next valid iterator", zh: "erase返回下一个有效iterator" } },
    { id: 46, category: { en: "STL", zh: "STL容器" }, question: { en: "set.lower_bound(key) returns?", zh: "set.lower_bound(key) 返回？" }, options: { en: ["First < key", "First >= key", "First > key", "First == key"], zh: ["第一个 < key", "第一个 >= key", "第一个 > key", "第一个 == key"] }, correct: 1, explanation: { en: "lower_bound returns first >= key", zh: "lower_bound返回>=key的第一个" } },
    { id: 47, category: { en: "STL", zh: "STL容器" }, question: { en: "map insert return value?", zh: "map insert 返回值？" }, options: { en: ["void", "iterator", "pair<iterator, bool>", "bool"], zh: ["void", "iterator", "pair<iterator, bool>", "bool"] }, correct: 2, explanation: { en: "Returns pair, bool indicates insertion success", zh: "返回pair，bool表示是否成功插入" } },
    { id: 48, category: { en: "STL", zh: "STL容器" }, question: { en: "emplace vs insert advantage?", zh: "emplace vs insert 优势？" }, options: { en: ["Safer", "In-place construction, less copying", "Simpler", "Faster lookup"], zh: ["更安全", "原地构造，减少拷贝", "更简洁", "更快查找"] }, correct: 1, explanation: { en: "emplace constructs directly in container", zh: "emplace直接在容器内构造元素" } },
    { id: 49, category: { en: "STL", zh: "STL容器" }, question: { en: "std::array swap time complexity?", zh: "std::array swap 时间复杂度？" }, options: { en: ["O(1)", "O(n)", "O(log n)", "O(n^2)"], zh: ["O(1)", "O(n)", "O(log n)", "O(n^2)"] }, correct: 1, explanation: { en: "array is on stack, swap needs element-by-element", zh: "array在栈上，swap需逐元素交换" } },
    { id: 50, category: { en: "STL", zh: "STL容器" }, question: { en: "Does shrink_to_fit guarantee release?", zh: "vector shrink_to_fit 保证释放？" }, options: { en: ["Yes guaranteed", "No, just a hint", "Always fails", "Depends on element type"], zh: ["能保证", "不能保证，只是提示", "总是失败", "取决于元素类型"] }, correct: 1, explanation: { en: "shrink_to_fit is a non-binding request", zh: "shrink_to_fit是非强制的建议" } },
    { id: 51, category: { en: "Functions", zh: "函数调用" }, question: { en: "When are virtual function defaults bound?", zh: "虚函数默认参数何时绑定？" }, options: { en: ["Runtime", "Compile time", "Link time", "Depends on call"], zh: ["运行时", "编译期", "链接期", "取决于调用方式"] }, correct: 1, explanation: { en: "Default arguments are bound at compile time", zh: "默认参数在编译期绑定" } },
    { id: 52, category: { en: "Functions", zh: "函数调用" }, question: { en: "Where is vtable usually located?", zh: "vtable 通常在对象什么位置？" }, options: { en: ["End of object", "Beginning of object", "Static area", "On heap"], zh: ["对象末尾", "对象开头", "静态区域", "堆上"] }, correct: 1, explanation: { en: "Usually vptr is at the beginning of object", zh: "通常在对象开头存放vptr" } },
    { id: 53, category: { en: "Functions", zh: "函数调用" }, question: { en: "Does inline guarantee function inlining?", zh: "inline 能保证函数内联吗？" }, options: { en: ["Yes", "No, just a suggestion", "Only in debug", "Depends on size"], zh: ["能保证", "不能保证，只是建议", "只在debug生效", "取决于大小"] }, correct: 1, explanation: { en: "inline just allows multiple definitions + suggests", zh: "inline只是允许多定义+建议" } },
    { id: 54, category: { en: "Functions", zh: "函数调用" }, question: { en: "Which overload match has priority?", zh: "函数重载时哪种匹配优先？" }, options: { en: ["Implicit conversion", "Exact match", "Template match", "Default parameter"], zh: ["隐式转换", "精确匹配", "模板匹配", "默认参数"] }, correct: 1, explanation: { en: "Exact match prioritized → implicit conversion", zh: "精确匹配优先→隐式转换" } },
    { id: 55, category: { en: "Functions", zh: "函数调用" }, question: { en: "Both template and regular function match?", zh: "函数模板和普通函数都能匹配？" }, options: { en: ["Function template", "Regular function", "Compilation error", "Random choice"], zh: ["函数模板", "普通函数", "编译错误", "随机选择"] }, correct: 1, explanation: { en: "Regular function has priority over template", zh: "普通函数比模板优先匹配" } },
    { id: 56, category: { en: "Functions", zh: "函数调用" }, question: { en: "Template deduction: pass by value vs ref?", zh: "模板推导时传值和传引用区别？" }, options: { en: ["No difference", "Affects const and ref deduction", "Pass by value faster", "Pass by ref fails"], zh: ["没有区别", "影响const和引用推导", "传值更快", "传引用会失败"] }, correct: 1, explanation: { en: "Affects type deduction", zh: "会影响类型推导" } },
    { id: 57, category: { en: "Functions", zh: "函数调用" }, question: { en: "Main purpose of rvalue reference &&?", zh: "右值引用 && 的主要用途？" }, options: { en: ["Logical AND", "Perfect forwarding and move", "Get address", "Type conversion"], zh: ["逻辑与运算", "完美转发和移动语义", "取地址", "类型转换"] }, correct: 1, explanation: { en: "Used for perfect forwarding and move semantics", zh: "用于完美转发、move语义" } },
    { id: 58, category: { en: "Functions", zh: "函数调用" }, question: { en: "What does explicit keyword do?", zh: "explicit 关键字作用？" }, options: { en: ["Export function", "Prevent implicit conversion", "Force inline", "Declare virtual"], zh: ["导出函数", "禁止隐式类型转换", "强制内联", "声明虚函数"] }, correct: 1, explanation: { en: "Prevents implicit conversion of constructors", zh: "禁止构造函数的隐式转换" } },
    { id: 59, category: { en: "Functions", zh: "函数调用" }, question: { en: "Difference between constexpr and const?", zh: "constexpr 和 const 区别？" }, options: { en: ["No difference", "constexpr must be compile-time", "const is faster", "constexpr only for functions"], zh: ["没有区别", "constexpr必须编译期", "const更快", "constexpr只用于函数"] }, correct: 1, explanation: { en: "constexpr must be compile-time constant", zh: "constexpr必须是编译期常量" } },
    { id: 60, category: { en: "Functions", zh: "函数调用" }, question: { en: "C++20 consteval characteristic?", zh: "C++20 consteval 特点？" }, options: { en: ["Can be runtime", "Must be compile-time", "Same as constexpr", "Only returns void"], zh: ["可以运行期求值", "必须编译期求值", "等同constexpr", "只能返回void"] }, correct: 1, explanation: { en: "consteval must be evaluated at compile time", zh: "consteval必须在编译期求值" } },
    { id: 61, category: { en: "Functions", zh: "函数调用" }, question: { en: "mutable member variable characteristic?", zh: "mutable 成员变量特点？" }, options: { en: ["Cannot be modified", "Can modify in const object", "Must be static", "Must be initialized"], zh: ["不能被修改", "const对象也能修改", "只能是static", "必须初始化"] }, correct: 1, explanation: { en: "mutable members can be modified in const functions", zh: "mutable成员可在const函数中修改" } },
    { id: 62, category: { en: "Functions", zh: "函数调用" }, question: { en: "What does [[nodiscard]] do?", zh: "[[nodiscard]] 属性作用？" }, options: { en: ["Prevent discarding object", "Return value must be used", "No exceptions", "Mark deprecated"], zh: ["禁止丢弃对象", "返回值必须使用", "不能抛异常", "标记废弃"] }, correct: 1, explanation: { en: "Requires caller to use return value", zh: "要求调用者使用返回值" } },
    { id: 63, category: { en: "Functions", zh: "函数调用" }, question: { en: "What does [[maybe_unused]] do?", zh: "[[maybe_unused]] 属性作用？" }, options: { en: ["Mark must use", "Suppress unused warnings", "Delay initialization", "Optimization hint"], zh: ["标记必须使用", "忽略未使用警告", "延迟初始化", "优化提示"] }, correct: 1, explanation: { en: "Tells compiler variable may be unused", zh: "告诉编译器变量可能不使用" } },
    { id: 64, category: { en: "Functions", zh: "函数调用" }, question: { en: "std::function vs function pointer?", zh: "std::function vs 函数指针？" }, options: { en: ["Faster", "Supports lambda with captures", "Less memory", "Simpler"], zh: ["更快", "支持lambda和捕获", "更省内存", "更简洁"] }, correct: 1, explanation: { en: "function can wrap any callable object", zh: "function可包装任何可调用对象" } },
    { id: 65, category: { en: "Functions", zh: "函数调用" }, question: { en: "Lambda value vs reference capture?", zh: "lambda 值捕获和引用捕获区别？" }, options: { en: ["No difference", "Value copies, ref needs lifetime care", "Reference faster", "Value can't modify"], zh: ["没有区别", "值拷贝，引用注意生命周期", "引用更快", "值捕获不能修改"] }, correct: 1, explanation: { en: "Value captures copy, reference needs lifetime care", zh: "值捕获会拷贝，引用需注意生命周期" } },
    { id: 66, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "auto x = expr; preserves const and ref?", zh: "auto x = expr; 保留const和ref？" }, options: { en: ["Yes", "No, cv-ref stripped", "Only const", "Only reference"], zh: ["会保留", "不会，cv-ref被去除", "只保留const", "只保留引用"] }, correct: 1, explanation: { en: "auto copy deduction strips const and reference", zh: "auto拷贝推导会去除const和引用" } },
    { id: 67, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "decltype(expr) preserves exact type?", zh: "decltype(expr) 保留精确类型？" }, options: { en: ["No", "Yes, including ref and const", "Only basic type", "Depends on expression"], zh: ["不会", "会，包括ref和const", "只保留基本类型", "取决于表达式"] }, correct: 1, explanation: { en: "decltype preserves exact type", zh: "decltype保留精确类型" } },
    { id: 68, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "range-based for is essentially?", zh: "range-based for 本质是？" }, options: { en: ["while loop", "Syntactic sugar for begin/end", "Recursion", "goto statement"], zh: ["while循环", "begin/end的语法糖", "递归", "goto语句"] }, correct: 1, explanation: { en: "Syntactic sugar calling begin() and end()", zh: "是调用begin()和end()的语法糖" } },
    { id: 69, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "nullptr vs NULL advantage?", zh: "nullptr vs NULL 优势？" }, options: { en: ["Faster", "Type-safe, not treated as 0", "Less memory", "Better compatibility"], zh: ["更快", "类型安全，不当作0", "更省内存", "兼容性更好"] }, correct: 1, explanation: { en: "nullptr is type-safe", zh: "nullptr是类型安全的" } },
    { id: 70, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "enum class vs enum advantage?", zh: "enum class vs enum 优势？" }, options: { en: ["Faster", "Strong type, scoped", "Less memory", "Supports float"], zh: ["更快", "强类型，作用域限定", "更省内存", "支持浮点"] }, correct: 1, explanation: { en: "enum class is strongly typed enum", zh: "enum class是强类型枚举" } },
    { id: 71, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "What does std::move actually do?", zh: "std::move 实际做了什么？" }, options: { en: ["Moves object", "Just casts to rvalue reference", "Copies object", "Deletes object"], zh: ["移动对象", "只是cast成右值引用", "复制对象", "删除对象"] }, correct: 1, explanation: { en: "Just type conversion, real move in ctor/assignment", zh: "只是类型转换，真正移动在构造/赋值中" } },
    { id: 72, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "What does std::forward do?", zh: "std::forward 的作用？" }, options: { en: ["Forward declaration", "Perfect forward, preserves value category", "Loop iteration", "Type conversion"], zh: ["前向声明", "完美转发，保留左右值", "循环遍历", "类型转换"] }, correct: 1, explanation: { en: "For perfect forwarding, preserves parameter attributes", zh: "用于完美转发，保留参数属性" } },
    { id: 73, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "std::optional access when uninitialized?", zh: "std::optional 未初始化访问？" }, options: { en: ["Returns default", "Returns nullptr", "Throws exception", "Undefined behavior"], zh: ["返回默认值", "返回nullptr", "抛出异常", "未定义行为"] }, correct: 2, explanation: { en: "Accessing empty optional throws exception", zh: "访问空optional会抛出异常" } },
    { id: 74, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "std::variant vs union advantage?", zh: "std::variant vs union 优势？" }, options: { en: ["Less memory", "Type-safe", "Faster", "Supports more types"], zh: ["更省内存", "类型安全", "更快", "支持更多类型"] }, correct: 1, explanation: { en: "variant is type-safe union", zh: "variant是类型安全的union" } },
    { id: 75, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "structured bindings in which version?", zh: "structured bindings 哪个版本？" }, options: { en: ["C++11", "C++14", "C++17", "C++20"], zh: ["C++11", "C++14", "C++17", "C++20"] }, correct: 2, explanation: { en: "Structured bindings introduced in C++17", zh: "结构化绑定是C++17引入的" } },
    { id: 76, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "What does if constexpr do?", zh: "if constexpr 的作用？" }, options: { en: ["Runtime condition", "Compile-time conditional branch", "Exception handling", "Type checking"], zh: ["运行时条件", "编译期条件分支", "异常处理", "类型检查"] }, correct: 1, explanation: { en: "if constexpr decides branch at compile time", zh: "if constexpr在编译期决定分支" } },
    { id: 77, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "inline variables (C++17) solve?", zh: "inline variables (C++17) 解决？" }, options: { en: ["Inline functions", "Header variables can be multiply included", "Constant folding", "Template instantiation"], zh: ["内联函数", "头文件变量可多次包含", "常量折叠", "模板实例化"] }, correct: 1, explanation: { en: "inline variables allow header file definitions", zh: "inline变量允许头文件定义" } },
    { id: 78, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "C++20 concept is used for?", zh: "C++20 concept 用于？" }, options: { en: ["OOP", "Template constraints", "Memory management", "Concurrency"], zh: ["面向对象", "模板约束", "内存管理", "并发编程"] }, correct: 1, explanation: { en: "concept is used to constrain template parameters", zh: "concept用于约束模板参数" } },
    { id: 79, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "C++20 bit_cast vs reinterpret_cast?", zh: "C++20 bit_cast vs reinterpret_cast？" }, options: { en: ["Faster", "Type-safe, avoids aliasing UB", "More general", "Supports more types"], zh: ["更快", "类型安全，避免aliasing UB", "更通用", "支持更多类型"] }, correct: 1, explanation: { en: "bit_cast provides safe bit-level conversion", zh: "bit_cast提供安全的位级转换" } },
    { id: 80, category: { en: "Modern C++", zh: "C++新特性" }, question: { en: "C++20 coroutine keywords?", zh: "C++20 协程关键字？" }, options: { en: ["async/await", "co_await/co_yield/co_return", "yield/resume", "coroutine/suspend"], zh: ["async/await", "co_await/co_yield/co_return", "yield/resume", "coroutine/suspend"] }, correct: 1, explanation: { en: "Uses co_await, co_yield, co_return", zh: "使用co_await、co_yield、co_return" } },
    { id: 81, category: { en: "Templates", zh: "模板系统" }, question: { en: "What does SFINAE stand for?", zh: "SFINAE 是什么的缩写？" }, options: { en: ["Standard Function...", "Substitution Failure Is Not An Error", "Static Function...", "Simple Format..."], zh: ["Standard Function...", "Substitution Failure Is Not An Error", "Static Function...", "Simple Format..."] }, correct: 1, explanation: { en: "Substitution Failure Is Not An Error", zh: "替换失败不是错误" } },
    { id: 82, category: { en: "Templates", zh: "模板系统" }, question: { en: "Partial vs full specialization difference?", zh: "模板偏特化和完全特化区别？" }, options: { en: ["No difference", "Partial matches some parameters", "Partial is faster", "Full only for classes"], zh: ["没有区别", "偏特化匹配部分参数", "偏特化更快", "完全特化只用于类"] }, correct: 1, explanation: { en: "Partial specialization matches some template parameters", zh: "偏特化匹配部分模板参数" } },
    { id: 83, category: { en: "Templates", zh: "模板系统" }, question: { en: "Non-type template parameter can be?", zh: "非类型模板参数可以是？" }, options: { en: ["Only int", "integral/pointer/reference etc", "Any type", "Only class types"], zh: ["只能是int", "integral/pointer/reference等", "任意类型", "只能是类类型"] }, correct: 1, explanation: { en: "Can be integral, pointer, reference, etc.", zh: "可以是整型、指针、引用等" } },
    { id: 84, category: { en: "Templates", zh: "模板系统" }, question: { en: "decltype(auto) vs auto difference?", zh: "decltype(auto) vs auto 区别？" }, options: { en: ["No difference", "decltype(auto) preserves ref/const", "auto more precise", "decltype(auto) faster"], zh: ["没有区别", "decltype(auto)保留ref/const", "auto更精确", "decltype(auto)更快"] }, correct: 1, explanation: { en: "decltype(auto) preserves exact type", zh: "decltype(auto)保留精确类型" } },
    { id: 85, category: { en: "Templates", zh: "模板系统" }, question: { en: "T&& in template may deduce to?", zh: "T&& 在模板中可能推导成？" }, options: { en: ["Only rvalue reference", "May be lvalue or rvalue reference", "Only lvalue reference", "Compilation error"], zh: ["只能是右值引用", "可能左值或右值引用", "只能是左值引用", "会编译错误"] }, correct: 1, explanation: { en: "T&& is forwarding reference, deduces to either", zh: "T&&是转发引用，可推导为左值或右值" } },
    { id: 86, category: { en: "Templates", zh: "模板系统" }, question: { en: "What does sizeof...(Args) do?", zh: "sizeof...(Args) 的作用？" }, options: { en: ["Total bytes of args", "Number of args in pack", "Max arg size", "Syntax error"], zh: ["求参数总字节数", "求参数包数量", "求最大参数大小", "语法错误"] }, correct: 1, explanation: { en: "Returns number of parameters in pack", zh: "返回参数包中的参数数量" } },
    { id: 87, category: { en: "Templates", zh: "模板系统" }, question: { en: "fold expression in which version?", zh: "fold expression 哪个版本？" }, options: { en: ["C++11", "C++14", "C++17", "C++20"], zh: ["C++11", "C++14", "C++17", "C++20"] }, correct: 2, explanation: { en: "Fold expressions introduced in C++17", zh: "折叠表达式是C++17引入的" } },
    { id: 88, category: { en: "Templates", zh: "模板系统" }, question: { en: "variadic templates allow?", zh: "variadic templates 允许？" }, options: { en: ["Variable return type", "Variable number of template params", "Variable function name", "Variable scope"], zh: ["可变返回类型", "可变数量模板参数", "可变函数名", "可变作用域"] }, correct: 1, explanation: { en: "Allows accepting any number of template parameters", zh: "允许接受任意数量的模板参数" } },
    { id: 89, category: { en: "Templates", zh: "模板系统" }, question: { en: "What does std::enable_if do?", zh: "std::enable_if 的作用？" }, options: { en: ["Enable function", "SFINAE template selection control", "Enable optimization", "Enable exceptions"], zh: ["启用函数", "SFINAE控制模板选择", "启用优化", "启用异常"] }, correct: 1, explanation: { en: "Uses SFINAE to conditionally enable templates", zh: "利用SFINAE有条件启用模板" } },
    { id: 90, category: { en: "Templates", zh: "模板系统" }, question: { en: "Which is NOT a type trait?", zh: "以下哪个不是 type traits？" }, options: { en: ["std::is_same", "std::is_base_of", "std::is_function", "std::is_allocated"], zh: ["std::is_same", "std::is_base_of", "std::is_function", "std::is_allocated"] }, correct: 3, explanation: { en: "std::is_allocated doesn't exist", zh: "std::is_allocated不存在" } },
    { id: 91, category: { en: "Common UB", zh: "常见UB" }, question: { en: "signed integer overflow is?", zh: "signed integer overflow 是？" }, options: { en: ["Defined as wrap-around", "Undefined behavior (UB)", "Throws exception", "Returns max value"], zh: ["定义为回绕", "未定义行为(UB)", "抛出异常", "返回最大值"] }, correct: 1, explanation: { en: "Signed integer overflow is UB", zh: "有符号整数溢出是UB" } },
    { id: 92, category: { en: "Common UB", zh: "常见UB" }, question: { en: "Accessing freed memory is?", zh: "访问已释放内存是？" }, options: { en: ["Returns 0", "Undefined behavior (UB)", "Throws exception", "Program terminates"], zh: ["返回0", "未定义行为(UB)", "抛出异常", "程序终止"] }, correct: 1, explanation: { en: "use-after-free is UB", zh: "use-after-free是UB" } },
    { id: 93, category: { en: "Common UB", zh: "常见UB" }, question: { en: "Array out-of-bounds access is?", zh: "数组越界访问是？" }, options: { en: ["Returns default", "Undefined behavior (UB)", "Throws exception", "Auto expands"], zh: ["返回默认值", "未定义行为(UB)", "抛出异常", "自动扩容"] }, correct: 1, explanation: { en: "Array out-of-bounds access is UB", zh: "数组越界访问是UB" } },
    { id: 94, category: { en: "Common UB", zh: "常见UB" }, question: { en: "Using dangling pointer is?", zh: "使用悬垂指针是？" }, options: { en: ["Returns NULL", "Undefined behavior (UB)", "Compilation error", "Throws exception"], zh: ["返回NULL", "未定义行为(UB)", "编译错误", "抛出异常"] }, correct: 1, explanation: { en: "Dangling pointer use is UB", zh: "悬垂指针使用是UB" } },
    { id: 95, category: { en: "Common UB", zh: "常见UB" }, question: { en: "Violating strict aliasing is?", zh: "违反 strict aliasing 是？" }, options: { en: ["Performance drop", "Undefined behavior (UB)", "Compiler warning", "Type conversion"], zh: ["性能下降", "未定义行为(UB)", "编译警告", "类型转换"] }, correct: 1, explanation: { en: "Violating strict aliasing is UB", zh: "违反strict aliasing是UB" } },
    { id: 96, category: { en: "Common UB", zh: "常见UB" }, question: { en: "Multi-threaded data race is?", zh: "多线程 data race 是？" }, options: { en: ["Program slows down", "Undefined behavior (UB)", "Deadlock", "Result undefined but defined behavior"], zh: ["程序变慢", "未定义行为(UB)", "死锁", "结果不确定但定义明确"] }, correct: 1, explanation: { en: "data race is UB", zh: "data race是UB" } },
    { id: 97, category: { en: "Common UB", zh: "常见UB" }, question: { en: "Left shift count >= type width is?", zh: "左移位数 >= 类型位宽是？" }, options: { en: ["Result is 0", "Undefined behavior (UB)", "Circular shift", "Compilation error"], zh: ["结果为0", "未定义行为(UB)", "循环移位", "编译错误"] }, correct: 1, explanation: { en: "Shift count >= width is UB", zh: "移位数>=位宽是UB" } },
    { id: 98, category: { en: "Common UB", zh: "常见UB" }, question: { en: "Using invalidated iterator is?", zh: "使用失效的迭代器是？" }, options: { en: ["Returns end()", "Undefined behavior (UB)", "Throws exception", "Auto updates"], zh: ["返回end()", "未定义行为(UB)", "抛出异常", "自动更新"] }, correct: 1, explanation: { en: "Using invalidated iterator is UB", zh: "使用失效迭代器是UB" } },
    { id: 99, category: { en: "Common UB", zh: "常见UB" }, question: { en: "Returning pointer to local object is?", zh: "返回局部对象指针是？" }, options: { en: ["Returns copy", "Undefined behavior (UB)", "Compilation error", "Returns NULL"], zh: ["返回副本", "未定义行为(UB)", "编译错误", "返回NULL"] }, correct: 1, explanation: { en: "Returning local pointer/reference is UB", zh: "返回局部对象指针/引用是UB" } },
    { id: 100, category: { en: "Common UB", zh: "常见UB" }, question: { en: "Multiple unsequenced modifications?", zh: "同一表达式多次修改变量（无序）？" }, options: { en: ["Left-to-right evaluation", "Undefined behavior (UB)", "Compilation error", "Random result"], zh: ["从左到右求值", "未定义行为(UB)", "编译错误", "随机结果"] }, correct: 1, explanation: { en: "e.g., i = i++ + ++i is UB", zh: "如 i = i++ + ++i 是UB" } }
];

// Helper to get localized text
function t(key) { return UI_TEXT[currentLang][key]; }
function q(question, field) {
    const val = question[field];
    return typeof val === 'object' ? val[currentLang] : val;
}

function getRandomQuestions(count) {
    return [...allQuestions].sort(() => Math.random() - 0.5).slice(0, count);
}

let gameState = { questions: [], currentIndex: 0, score: 0, answers: [], totalQuestions: 20 };

// Detect mobile
const isMobile = window.innerWidth <= 768;
const GAME_WIDTH = isMobile ? window.innerWidth : 800;
const GAME_HEIGHT = isMobile ? window.innerHeight : 650;

// Font sizes - different for mobile and desktop
const FONT = {
    title: isMobile ? 52 : 56,
    subtitle: isMobile ? 32 : 32,
    info: isMobile ? 20 : 18,
    category: isMobile ? 18 : 15,
    question: isMobile ? 22 : 20,
    option: isMobile ? 20 : 17,
    optionLabel: isMobile ? 22 : 18,
    button: isMobile ? 24 : 22,
    explanation: isMobile ? 18 : 15,
    score: isMobile ? 64 : 64,
    percent: isMobile ? 28 : 26,
    review: isMobile ? 16 : 14,
    reviewSmall: isMobile ? 14 : 12,
    langBtn: isMobile ? 14 : 12
};

class BootScene extends Phaser.Scene {
    constructor() { super({ key: 'BootScene' }); }
    create() {
        document.getElementById('loading').style.display = 'none';
        this.scene.start('MenuScene');
    }
}

class MenuScene extends Phaser.Scene {
    constructor() { super({ key: 'MenuScene' }); }

    create() {
        const { width, height } = this.cameras.main;
        this.createBg();

        // Language button (top right)
        this.createLangBtn(width - 50, 25);

        const title = this.add.text(width / 2, height * 0.15, 'C++ Trivials', {
            fontSize: FONT.title + 'px', fontFamily: 'Arial Black', color: '#00d4ff', stroke: '#0066cc', strokeThickness: 4
        }).setOrigin(0.5);
        this.tweens.add({ targets: title, alpha: 0.8, duration: 1500, yoyo: true, repeat: -1 });

        this.subtitleTxt = this.add.text(width / 2, height * 0.26, t('subtitle'), {
            fontSize: FONT.subtitle + 'px', fontFamily: 'Arial', color: '#fff'
        }).setOrigin(0.5);

        this.infoTxt = this.add.text(width / 2, height * 0.38, t('info'), {
            fontSize: FONT.info + 'px', fontFamily: 'Arial', color: '#888', align: 'center', lineSpacing: 6
        }).setOrigin(0.5);

        const startY = height * 0.50;
        this.catTexts = t('categories').map((c, i) => {
            return this.add.text(width / 2, startY + i * (isMobile ? 28 : 24), c, {
                fontSize: FONT.category + 'px', fontFamily: 'Arial', color: '#4a9eff'
            }).setOrigin(0.5);
        });

        this.startBtnTxt = null;
        this.createBtn(width / 2, height * 0.88, t('startGame'), () => {
            gameState = { questions: getRandomQuestions(20), currentIndex: 0, score: 0, answers: [], totalQuestions: 20 };
            this.cameras.main.fadeOut(400);
            this.time.delayedCall(400, () => this.scene.start('GameScene'));
        });

        this.createParticles();
    }

    createBg() {
        const { width, height } = this.cameras.main;
        const g = this.add.graphics();
        for (let i = 0; i < height; i++) {
            const r = i / height;
            g.fillStyle(Phaser.Display.Color.GetColor(26 + r * 10, 26 + r * 15, 46 + r * 20));
            g.fillRect(0, i, width, 1);
        }
        for (let i = 0; i < 5; i++) this.add.circle(Phaser.Math.Between(0, width), Phaser.Math.Between(0, height), Phaser.Math.Between(40, 120), 0x4a9eff, 0.03);
    }

    createLangBtn(x, y) {
        const bw = 60, bh = 28;
        const c = this.add.container(x, y);
        const bg = this.add.graphics().fillStyle(0x333355, 1).lineStyle(1, 0x4a9eff, 0.5).fillRoundedRect(-bw/2, -bh/2, bw, bh, 6).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 6);
        this.langBtnTxt = this.add.text(0, 0, t('langBtn'), { fontSize: FONT.langBtn + 'px', fontFamily: 'Arial', color: '#4a9eff' }).setOrigin(0.5);
        c.add([bg, this.langBtnTxt]).setSize(bw, bh).setInteractive({ useHandCursor: true });
        c.on('pointerover', () => bg.clear().fillStyle(0x444466, 1).lineStyle(1, 0x6ab4ff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 6).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 6));
        c.on('pointerout', () => bg.clear().fillStyle(0x333355, 1).lineStyle(1, 0x4a9eff, 0.5).fillRoundedRect(-bw/2, -bh/2, bw, bh, 6).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 6));
        c.on('pointerdown', () => {
            currentLang = currentLang === 'en' ? 'zh' : 'en';
            this.scene.restart();
        });
    }

    createBtn(x, y, text, cb) {
        const bw = isMobile ? 220 : 200, bh = isMobile ? 56 : 50;
        const c = this.add.container(x, y);
        const bg = this.add.graphics();
        bg.fillStyle(0x4a9eff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 12);
        this.startBtnTxt = this.add.text(0, 0, text, { fontSize: FONT.button + 'px', fontFamily: 'Arial', color: '#fff' }).setOrigin(0.5);
        c.add([bg, this.startBtnTxt]);
        c.setSize(bw, bh).setInteractive({ useHandCursor: true });
        c.on('pointerover', () => { bg.clear().fillStyle(0x6ab4ff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 12); });
        c.on('pointerout', () => { bg.clear().fillStyle(0x4a9eff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 12); });
        c.on('pointerdown', cb);
    }

    createParticles() {
        const { width, height } = this.cameras.main;
        for (let i = 0; i < 15; i++) {
            const p = this.add.circle(Phaser.Math.Between(0, width), Phaser.Math.Between(0, height), Phaser.Math.Between(2, 4), 0x4a9eff, 0.5);
            this.tweens.add({ targets: p, y: p.y - 100, alpha: 0, duration: Phaser.Math.Between(3000, 5000), repeat: -1,
                onRepeat: () => { p.x = Phaser.Math.Between(0, width); p.y = height + 20; p.alpha = 0.5; }
            });
        }
    }
}

class GameScene extends Phaser.Scene {
    constructor() { super({ key: 'GameScene' }); this.btns = []; this.canAnswer = true; }

    create() {
        const { width, height } = this.cameras.main;
        this.cameras.main.fadeIn(400);
        this.createBg();

        // Language button
        this.createLangBtn(width - 50, 25);

        const barY = height * 0.03, barH = isMobile ? 18 : 16;
        this.add.graphics().fillStyle(0x333355, 1).fillRoundedRect(20, barY, width - 100, barH, 8);
        this.progressBar = this.add.graphics();

        const infoY = barY + barH + 8;
        this.numTxt = this.add.text(20, infoY, '', { fontSize: FONT.info + 'px', fontFamily: 'Arial', color: '#888' });
        this.scoreTxt = this.add.text(width - 70, infoY, '', { fontSize: FONT.info + 'px', fontFamily: 'Arial', color: '#4a9eff' }).setOrigin(1, 0);
        this.catTxt = this.add.text(width / 2, infoY + (isMobile ? 30 : 26), '', { fontSize: FONT.category + 'px', fontFamily: 'Arial', color: '#666' }).setOrigin(0.5);

        const qY = height * 0.15, qH = height * 0.20;
        this.add.graphics().fillStyle(0x252540, 0.9).fillRoundedRect(15, qY, width - 30, qH, 12);
        this.qTxt = this.add.text(width / 2, qY + qH / 2, '', {
            fontSize: FONT.question + 'px', fontFamily: 'Arial', color: '#fff', wordWrap: { width: width - 50 }, align: 'center', lineSpacing: 4
        }).setOrigin(0.5);

        this.createOptions();

        const expY = height * 0.92;
        this.expC = this.add.container(width / 2, expY).setVisible(false);
        const expBg = this.add.graphics().fillStyle(0x333355, 0.9).fillRoundedRect(-(width/2 - 15), -22, width - 30, 44, 8);
        this.expTxt = this.add.text(0, 0, '', { fontSize: FONT.explanation + 'px', fontFamily: 'Arial', color: '#aaa', wordWrap: { width: width - 50 }, align: 'center' }).setOrigin(0.5);
        this.expC.add([expBg, this.expTxt]);

        this.showQ();
    }

    createBg() {
        const { width, height } = this.cameras.main;
        const g = this.add.graphics();
        for (let i = 0; i < height; i++) {
            const r = i / height;
            g.fillStyle(Phaser.Display.Color.GetColor(26 + r * 10, 26 + r * 15, 46 + r * 20));
            g.fillRect(0, i, width, 1);
        }
    }

    createLangBtn(x, y) {
        const bw = 60, bh = 28;
        const c = this.add.container(x, y);
        const bg = this.add.graphics().fillStyle(0x333355, 1).lineStyle(1, 0x4a9eff, 0.5).fillRoundedRect(-bw/2, -bh/2, bw, bh, 6).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 6);
        const txt = this.add.text(0, 0, t('langBtn'), { fontSize: FONT.langBtn + 'px', fontFamily: 'Arial', color: '#4a9eff' }).setOrigin(0.5);
        c.add([bg, txt]).setSize(bw, bh).setInteractive({ useHandCursor: true });
        c.on('pointerover', () => bg.clear().fillStyle(0x444466, 1).lineStyle(1, 0x6ab4ff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 6).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 6));
        c.on('pointerout', () => bg.clear().fillStyle(0x333355, 1).lineStyle(1, 0x4a9eff, 0.5).fillRoundedRect(-bw/2, -bh/2, bw, bh, 6).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 6));
        c.on('pointerdown', () => {
            currentLang = currentLang === 'en' ? 'zh' : 'en';
            this.showQ();
        });
    }

    createOptions() {
        const { width, height } = this.cameras.main;
        const startY = height * 0.38, spacing = height * 0.13;
        const bw = width - 30, bh = isMobile ? 58 : 50;
        this.btns = [];

        for (let i = 0; i < 4; i++) {
            const y = startY + i * spacing;
            const c = this.add.container(width / 2, y);
            const bg = this.add.graphics().fillStyle(0x2a2a4a, 1).lineStyle(2, 0x4a9eff, 0.5)
                .fillRoundedRect(-bw/2, -bh/2, bw, bh, 10).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 10);
            const lbl = this.add.text(-bw/2 + 15, 0, String.fromCharCode(65 + i) + '.', {
                fontSize: FONT.optionLabel + 'px', fontFamily: 'Arial Black', color: '#4a9eff'
            }).setOrigin(0, 0.5);
            const txt = this.add.text(-bw/2 + (isMobile ? 50 : 45), 0, '', {
                fontSize: FONT.option + 'px', fontFamily: 'Arial', color: '#fff', wordWrap: { width: bw - 70 }
            }).setOrigin(0, 0.5);

            c.add([bg, lbl, txt]).setSize(bw, bh).setInteractive({ useHandCursor: true });
            c.bg = bg; c.txt = txt; c.lbl = lbl; c.bw = bw; c.bh = bh; c.idx = i;

            c.on('pointerover', () => { if (!this.canAnswer) return; bg.clear().fillStyle(0x3a3a5a, 1).lineStyle(2, 0x6ab4ff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 10); });
            c.on('pointerout', () => { if (!this.canAnswer) return; bg.clear().fillStyle(0x2a2a4a, 1).lineStyle(2, 0x4a9eff, 0.5).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 10); });
            c.on('pointerdown', () => { if (this.canAnswer) this.answer(i); });

            this.btns.push(c);
        }
    }

    showQ() {
        const { width, height } = this.cameras.main;
        const question = gameState.questions[gameState.currentIndex];
        const barY = height * 0.03, barH = isMobile ? 18 : 16;

        const prog = gameState.currentIndex / gameState.totalQuestions;
        this.progressBar.clear().fillStyle(0x4a9eff, 1);
        if (prog > 0) this.progressBar.fillRoundedRect(20, barY, (width - 100) * prog, barH, 8);

        this.numTxt.setText(`${gameState.currentIndex + 1}/${gameState.totalQuestions}`);
        this.scoreTxt.setText(`${t('score')}: ${gameState.score}`);
        this.catTxt.setText(q(question, 'category'));
        this.qTxt.setText(q(question, 'question'));

        this.canAnswer = true;
        this.expC.setVisible(false);

        const options = q(question, 'options');
        this.btns.forEach((b, i) => {
            const { bw, bh } = b;
            b.txt.setText(options[i]);
            b.setAlpha(0).x = width / 2 + 30;
            b.bg.clear().fillStyle(0x2a2a4a, 1).lineStyle(2, 0x4a9eff, 0.5).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 10);
            b.lbl.setColor('#4a9eff');
            b.txt.setColor('#fff');
            this.tweens.add({ targets: b, alpha: 1, x: width / 2, duration: 200, delay: i * 50, ease: 'Back.easeOut' });
        });
    }

    answer(idx) {
        this.canAnswer = false;
        const question = gameState.questions[gameState.currentIndex];
        const ok = idx === question.correct;
        gameState.answers.push({ question: question, selected: idx, correct: ok });
        if (ok) { gameState.score++; this.scoreTxt.setText(`${t('score')}: ${gameState.score}`); }

        this.btns.forEach((b, i) => {
            const { bw, bh } = b;
            if (i === question.correct) {
                b.bg.clear().fillStyle(0x2a5a2a, 1).lineStyle(3, 0x4aff4a, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 10);
                b.lbl.setColor('#4aff4a');
                if (ok) this.burst(b.x, b.y);
            } else if (i === idx) {
                b.bg.clear().fillStyle(0x5a2a2a, 1).lineStyle(3, 0xff4a4a, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 10);
                b.lbl.setColor('#ff4a4a'); b.txt.setColor('#ff8888');
                this.tweens.add({ targets: b, x: b.x + 8, duration: 40, yoyo: true, repeat: 3 });
            } else {
                b.setAlpha(0.4);
            }
        });

        this.expTxt.setText(q(question, 'explanation'));
        this.expC.setVisible(true).setAlpha(0);
        this.tweens.add({ targets: this.expC, alpha: 1, duration: 200 });
        this.time.delayedCall(1600, () => this.next());
    }

    burst(x, y) {
        for (let i = 0; i < 8; i++) {
            const a = (i / 8) * Math.PI * 2;
            const p = this.add.circle(x, y, 5, 0x4aff4a);
            this.tweens.add({ targets: p, x: x + Math.cos(a) * 50, y: y + Math.sin(a) * 25, alpha: 0, scale: 0, duration: 350, onComplete: () => p.destroy() });
        }
    }

    next() {
        gameState.currentIndex++;
        if (gameState.currentIndex >= gameState.totalQuestions) {
            this.cameras.main.fadeOut(400);
            this.time.delayedCall(400, () => this.scene.start('ResultScene'));
        } else {
            this.btns.forEach((b, i) => {
                this.tweens.add({ targets: b, x: -100, alpha: 0, duration: 120, delay: i * 30, onComplete: () => { if (i === 3) this.showQ(); } });
            });
        }
    }
}

class ResultScene extends Phaser.Scene {
    constructor() { super({ key: 'ResultScene' }); }

    create() {
        const { width, height } = this.cameras.main;
        this.cameras.main.fadeIn(400);
        this.createBg();

        // Language button
        this.createLangBtn(width - 50, 25);

        const pct = Math.round((gameState.score / gameState.totalQuestions) * 100);
        let title, color;
        if (pct >= 90) { title = t('excellent'); color = '#4aff4a'; }
        else if (pct >= 70) { title = t('greatJob'); color = '#4a9eff'; }
        else if (pct >= 50) { title = t('goodTry'); color = '#ffaa4a'; }
        else { title = t('keepLearning'); color = '#ff6a6a'; }

        this.add.text(width / 2, height * 0.12, title, { fontSize: (isMobile ? 44 : 42) + 'px', fontFamily: 'Arial Black', color }).setOrigin(0.5);

        this.scoreDisp = this.add.text(width / 2, height * 0.26, '0', { fontSize: FONT.score + 'px', fontFamily: 'Arial Black', color: '#fff' }).setOrigin(0.5);
        this.add.text(width / 2, height * 0.34, `${t('outOf')} ${gameState.totalQuestions}`, { fontSize: (isMobile ? 22 : 20) + 'px', fontFamily: 'Arial', color: '#888' }).setOrigin(0.5);

        let disp = 0;
        this.time.addEvent({ delay: 40, repeat: gameState.score, callback: () => { disp++; this.scoreDisp.setText(disp.toString()); } });

        this.drawCircle(width / 2, height * 0.50, pct);

        const correct = gameState.answers.filter(a => a.correct).length;
        const wrong = gameState.totalQuestions - correct;
        this.add.text(width / 2 - 60, height * 0.66, `${t('correct')}: ${correct}`, { fontSize: (isMobile ? 20 : 18) + 'px', fontFamily: 'Arial', color: '#4aff4a' }).setOrigin(0.5);
        this.add.text(width / 2 + 60, height * 0.66, `${t('wrong')}: ${wrong}`, { fontSize: (isMobile ? 20 : 18) + 'px', fontFamily: 'Arial', color: '#ff6a6a' }).setOrigin(0.5);

        const btnY = height * 0.80;
        this.createBtn(width / 2 - 75, btnY, t('again'), () => { this.cameras.main.fadeOut(400); this.time.delayedCall(400, () => this.scene.start('MenuScene')); });
        this.createBtn(width / 2 + 75, btnY, t('review'), () => this.showReview());

        if (pct >= 70) this.confetti();
    }

    createBg() {
        const { width, height } = this.cameras.main;
        const g = this.add.graphics();
        for (let i = 0; i < height; i++) {
            const r = i / height;
            g.fillStyle(Phaser.Display.Color.GetColor(26 + r * 10, 26 + r * 15, 46 + r * 20));
            g.fillRect(0, i, width, 1);
        }
    }

    createLangBtn(x, y) {
        const bw = 60, bh = 28;
        const c = this.add.container(x, y);
        const bg = this.add.graphics().fillStyle(0x333355, 1).lineStyle(1, 0x4a9eff, 0.5).fillRoundedRect(-bw/2, -bh/2, bw, bh, 6).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 6);
        const txt = this.add.text(0, 0, t('langBtn'), { fontSize: FONT.langBtn + 'px', fontFamily: 'Arial', color: '#4a9eff' }).setOrigin(0.5);
        c.add([bg, txt]).setSize(bw, bh).setInteractive({ useHandCursor: true });
        c.on('pointerover', () => bg.clear().fillStyle(0x444466, 1).lineStyle(1, 0x6ab4ff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 6).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 6));
        c.on('pointerout', () => bg.clear().fillStyle(0x333355, 1).lineStyle(1, 0x4a9eff, 0.5).fillRoundedRect(-bw/2, -bh/2, bw, bh, 6).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 6));
        c.on('pointerdown', () => {
            currentLang = currentLang === 'en' ? 'zh' : 'en';
            this.scene.restart();
        });
    }

    drawCircle(x, y, pct) {
        const rad = isMobile ? 55 : 50;
        this.add.graphics().lineStyle(8, 0x333355, 1).arc(x, y, rad, 0, Math.PI * 2).strokePath();
        const pg = this.add.graphics();
        const col = pct >= 70 ? 0x4aff4a : pct >= 50 ? 0xffaa4a : 0xff6a6a;
        this.tweens.addCounter({
            from: -Math.PI / 2, to: -Math.PI / 2 + (pct / 100) * Math.PI * 2, duration: 700,
            onUpdate: t => { pg.clear().lineStyle(8, col, 1).beginPath().arc(x, y, rad, -Math.PI / 2, t.getValue()).strokePath(); }
        });
        this.add.text(x, y, pct + '%', { fontSize: FONT.percent + 'px', fontFamily: 'Arial Black', color: '#fff' }).setOrigin(0.5);
    }

    createBtn(x, y, text, cb) {
        const bw = isMobile ? 130 : 110, bh = isMobile ? 48 : 42;
        const c = this.add.container(x, y);
        const bg = this.add.graphics().fillStyle(0x4a9eff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10);
        c.add([bg, this.add.text(0, 0, text, { fontSize: (isMobile ? 20 : 18) + 'px', fontFamily: 'Arial', color: '#fff' }).setOrigin(0.5)]);
        c.setSize(bw, bh).setInteractive({ useHandCursor: true });
        c.on('pointerover', () => bg.clear().fillStyle(0x6ab4ff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10));
        c.on('pointerout', () => bg.clear().fillStyle(0x4a9eff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10));
        c.on('pointerdown', cb);
    }

    confetti() {
        const { width, height } = this.cameras.main;
        const cols = [0x4aff4a, 0x4a9eff, 0xffaa4a, 0xff6aff, 0xffff4a];
        for (let i = 0; i < 20; i++) {
            const px = Phaser.Math.Between(0, width);
            const p = this.add.rectangle(px, -10, 6, 6, Phaser.Utils.Array.GetRandom(cols)).setRotation(Math.PI / 4);
            this.tweens.add({ targets: p, y: height + 30, x: px + Phaser.Math.Between(-60, 60), rotation: p.rotation + Math.PI * 2, duration: Phaser.Math.Between(1500, 2500), delay: Phaser.Math.Between(0, 1000), repeat: -1 });
        }
    }

    showReview() {
        this.children.removeAll();
        const { width, height } = this.cameras.main;
        this.createBg();

        this.add.text(width / 2, 22, t('review'), { fontSize: (isMobile ? 28 : 26) + 'px', fontFamily: 'Arial Black', color: '#4a9eff' }).setOrigin(0.5);

        // Language button in review
        this.createLangBtn(width - 50, 25);

        let scrollY = 0;
        const itemH = isMobile ? 105 : 90;
        const contentH = gameState.answers.length * itemH + 60;
        const cont = this.add.container(0, 50);

        gameState.answers.forEach((a, i) => {
            const y = i * itemH;
            const ok = a.correct;
            cont.add(this.add.graphics().fillStyle(ok ? 0x2a4a2a : 0x4a2a2a, 0.8).fillRoundedRect(10, y, width - 20, itemH - 8, 8));
            cont.add(this.add.text(18, y + 6, `${i + 1}. ${ok ? '\u2713' : '\u2717'}`, { fontSize: FONT.review + 'px', fontFamily: 'Arial Black', color: ok ? '#4aff4a' : '#ff6a6a' }));
            cont.add(this.add.text(18, y + 28, q(a.question, 'question'), { fontSize: FONT.review + 'px', fontFamily: 'Arial', color: '#fff', wordWrap: { width: width - 36 } }));
            const options = q(a.question, 'options');
            const ans = options[a.question.correct];
            if (!ok) {
                cont.add(this.add.text(18, y + 54, `${t('your')}: ${options[a.selected]}`, { fontSize: FONT.reviewSmall + 'px', fontFamily: 'Arial', color: '#ff8888' }));
                cont.add(this.add.text(18, y + 72, `${t('answer')}: ${ans}`, { fontSize: FONT.reviewSmall + 'px', fontFamily: 'Arial', color: '#88ff88' }));
            } else {
                cont.add(this.add.text(18, y + 58, `${t('answer')}: ${ans}`, { fontSize: FONT.reviewSmall + 'px', fontFamily: 'Arial', color: '#88ff88' }));
            }
        });

        this.input.on('wheel', (p, g, dx, dy) => {
            scrollY = Phaser.Math.Clamp(scrollY - dy * 0.5, -(contentH - height + 100), 0);
            cont.y = 50 + scrollY;
        });

        let startY = 0, startScroll = 0;
        this.input.on('pointerdown', p => { startY = p.y; startScroll = scrollY; });
        this.input.on('pointermove', p => {
            if (p.isDown) {
                scrollY = Phaser.Math.Clamp(startScroll + (p.y - startY), -(contentH - height + 100), 0);
                cont.y = 50 + scrollY;
            }
        });

        this.createBtn(width / 2, height - 32, t('back'), () => { this.cameras.main.fadeOut(400); this.time.delayedCall(400, () => this.scene.start('MenuScene')); });
    }
}

const config = {
    type: Phaser.AUTO,
    width: GAME_WIDTH,
    height: GAME_HEIGHT,
    parent: 'game-container',
    backgroundColor: '#1a1a2e',
    scene: [BootScene, MenuScene, GameScene, ResultScene],
    scale: isMobile ? { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH } : { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH }
};

new Phaser.Game(config);
    </script>
</body>
</html>
