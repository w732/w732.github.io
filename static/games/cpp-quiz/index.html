<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>C++ Trivials Quiz Game</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex; justify-content: center; align-items: center; min-height: 100vh;
        }
        #game-container {
            user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
        }
        /* Desktop */
        @media (min-width: 769px) {
            #game-container {
                width: 800px; height: 650px; border-radius: 16px; overflow: hidden;
                box-shadow: 0 0 60px rgba(74, 158, 255, 0.3), 0 0 100px rgba(74, 158, 255, 0.1);
                border: 1px solid rgba(74, 158, 255, 0.2);
            }
            #game-container canvas { border-radius: 16px; }
        }
        /* Mobile */
        @media (max-width: 768px) {
            #game-container { width: 100vw; height: 100vh; }
        }
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1a1a2e; display: flex; justify-content: center; align-items: center;
            z-index: 1000; color: #4a9eff; font-size: 20px;
        }
        .spinner {
            width: 40px; height: 40px; border: 3px solid rgba(74, 158, 255, 0.3);
            border-top-color: #4a9eff; border-radius: 50%;
            animation: spin 1s linear infinite; margin-right: 12px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loading"><div class="spinner"></div>Loading...</div>
    <div id="game-container"></div>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <script>
const allQuestions = [
    { id: 1, category: "Basic Types", question: "What is sizeof('a') in C++?", options: ["1 (char type)", "4 (int type)", "2 (short type)", "Compiler dependent"], correct: 0, explanation: "In C it's int(4), in C++ it's char(1)" },
    { id: 2, category: "Basic Types", question: "Is char signed or unsigned by default?", options: ["signed", "unsigned", "implementation-defined", "Always signed char"], correct: 2, explanation: "Implementation-defined, better to declare explicitly" },
    { id: 3, category: "Basic Types", question: "What is the result of -1 < 1u?", options: ["true", "false", "Compilation error", "Undefined behavior"], correct: 1, explanation: "-1 converts to unsigned becoming a large positive number" },
    { id: 4, category: "Basic Types", question: "What is the result type of uint8_t + uint8_t?", options: ["uint8_t", "uint16_t", "int (integer promotion)", "unsigned int"], correct: 2, explanation: "Integer promotion promotes small integer types to int" },
    { id: 5, category: "Basic Types", question: "Before C++17, what is 1 << 31?", options: ["Equals INT_MIN", "Equals 0", "Undefined behavior (UB)", "Compilation error"], correct: 2, explanation: "Signed int left shift overflow is UB" },
    { id: 6, category: "Basic Types", question: "What is the result of 0.1 + 0.2 == 0.3?", options: ["true", "false", "Compilation error", "Compiler dependent"], correct: 1, explanation: "Floating-point precision issues cause inequality" },
    { id: 7, category: "Basic Types", question: "int a=1; a=a++ + ++a; result?", options: ["4", "5", "3", "Undefined behavior (UB)"], correct: 3, explanation: "Multiple modifications without sequence point is UB" },
    { id: 8, category: "Basic Types", question: "What is the type of nullptr?", options: ["void*", "int", "std::nullptr_t", "NULL"], correct: 2, explanation: "std::nullptr_t, implicitly convertible to any pointer" },
    { id: 9, category: "Basic Types", question: "What is sizeof(bool)?", options: ["Always 1", "Always 4", "implementation-defined", "Always 0"], correct: 2, explanation: "Implementation-defined, typically 1 byte" },
    { id: 10, category: "Basic Types", question: "0xFFFFFFFF in signed 32-bit int is?", options: ["4294967295", "-1", "0", "Overflow error"], correct: 1, explanation: "Signed is -1; unsigned is 4294967295" },
    { id: 11, category: "Basic Types", question: "What is true + true?", options: ["true", "2", "Compilation error", "Undefined behavior"], correct: 1, explanation: "Bool in arithmetic, true promotes to 1" },
    { id: 12, category: "Basic Types", question: "signed char c = 255; what is c?", options: ["255", "-1", "0", "Undefined behavior"], correct: 1, explanation: "signed char range is -128 to 127, overflow becomes -1" },
    { id: 13, category: "Basic Types", question: "Difference between int* p = 0 and nullptr?", options: ["Different functionality", "nullptr is type-safe", "0 is faster", "No difference"], correct: 1, explanation: "nullptr is type-safe, won't be confused with integer" },
    { id: 14, category: "Basic Types", question: "auto x = {1, 2}; what is x's type?", options: ["int[]", "vector<int>", "initializer_list<int>", "array<int,2>"], correct: 2, explanation: "Brace initialization deduces to initializer_list" },
    { id: 15, category: "Basic Types", question: "What does const int* p mean?", options: ["Pointer is const", "Pointed object is const", "Both are const", "Syntax error"], correct: 1, explanation: "const modifies left side → pointed object is const" },
    { id: 16, category: "Memory", question: "Main difference between malloc and new?", options: ["No difference", "malloc doesn't call constructor", "new doesn't allocate memory", "malloc is faster"], correct: 1, explanation: "malloc only allocates memory without calling constructor" },
    { id: 17, category: "Memory", question: "new[] allocated, using delete to free?", options: ["Normal release", "Undefined behavior (UB)", "Compilation error", "Only frees first"], correct: 1, explanation: "delete and delete[] must match" },
    { id: 18, category: "Memory", question: "What happens when returning reference to local?", options: ["Works normally", "Compilation error", "Undefined behavior (UB)", "Returns copy"], correct: 2, explanation: "Stack is released after function return, it's UB" },
    { id: 19, category: "Memory", question: "What does placement new do?", options: ["Allocates more memory", "Constructs on existing memory", "Auto-releases memory", "Creates multiple objects"], correct: 1, explanation: "Constructs object on already allocated memory" },
    { id: 20, category: "Memory", question: "memset to initialize std::string?", options: ["Works normally", "Undefined behavior (UB)", "Compilation error", "String becomes empty"], correct: 1, explanation: "memset only works on trivial objects" },
    { id: 21, category: "Memory", question: "Size of empty class (class Empty{};)?", options: ["0", "1", "4", "8"], correct: 1, explanation: "1 byte, ensures each object has unique address" },
    { id: 22, category: "Memory", question: "Destructor call order?", options: ["Base → Derived", "Derived → Base", "Called simultaneously", "Only derived"], correct: 1, explanation: "Destruction order is Derived → Base" },
    { id: 23, category: "Memory", question: "Static object destruction order across TUs?", options: ["Declaration order", "Alphabetical order", "Unspecified", "Simultaneous"], correct: 2, explanation: "Order across translation units is unspecified" },
    { id: 24, category: "Memory", question: "Does volatile guarantee thread safety?", options: ["Yes", "No", "On some platforms", "Compiler dependent"], correct: 1, explanation: "volatile only prevents optimization, not thread-safe" },
    { id: 25, category: "Memory", question: "Accessing after delete is what?", options: ["Returns default", "Undefined behavior (UB)", "Throws exception", "Returns NULL"], correct: 1, explanation: "use-after-free is undefined behavior" },
    { id: 26, category: "Memory", question: "What is a dangling reference?", options: ["Null reference", "Reference to freed object", "const reference", "Temporary reference"], correct: 1, explanation: "Reference bound to freed object → dangling reference" },
    { id: 27, category: "Memory", question: "Which is correct about references?", options: ["Can be uninitialized", "Must be initialized", "Can be rebound", "Can be null"], correct: 1, explanation: "References must be initialized at declaration" },
    { id: 28, category: "Memory", question: "Advantage of move semantics?", options: ["Safer", "Steals resources avoiding copy", "Cleaner code", "Better compatibility"], correct: 1, explanation: "Move semantics avoids unnecessary deep copies" },
    { id: 29, category: "Memory", question: "Copy constructor vs copy assignment?", options: ["No difference", "New object vs assign existing", "One uses = one uses ()", "Different efficiency"], correct: 1, explanation: "Copy ctor creates new, assignment assigns to existing" },
    { id: 30, category: "Memory", question: "Difference between T t; and T t{};?", options: ["No difference", "default vs value initialization", "Syntactic sugar", "Compiler optimization"], correct: 1, explanation: "T t; is default, T t{}; is value initialization" },
    { id: 31, category: "STL", question: "What does vector push_back invalidate?", options: ["Only iterator", "iterator/pointer/reference all may", "Nothing invalidated", "Only reference"], correct: 1, explanation: "All may invalidate on reallocation" },
    { id: 32, category: "STL", question: "deque insert at ends, what invalidates?", options: ["Nothing", "Iterator invalidates, reference doesn't", "All invalidate", "Only pointer"], correct: 1, explanation: "End insertion: Iterator invalid, Reference valid" },
    { id: 33, category: "STL", question: "list insert, does iterator invalidate?", options: ["Yes", "No (except deleted node)", "Partial", "Depends on position"], correct: 1, explanation: "list is linked, insert doesn't affect other iterators" },
    { id: 34, category: "STL", question: "map operator[] on non-existent key?", options: ["Throws exception", "Returns default", "Inserts default", "Returns end()"], correct: 2, explanation: "operator[] inserts a default-valued element" },
    { id: 35, category: "STL", question: "Difference between map find and operator[]?", options: ["No difference", "find doesn't insert, [] does", "find is faster", "[] is safer"], correct: 1, explanation: "find returns end() if not found, doesn't insert" },
    { id: 36, category: "STL", question: "unordered_map iteration order?", options: ["Sorted by key", "Insertion order", "Unstable/unspecified", "Hash order"], correct: 2, explanation: "Hash-based, iteration order is unstable" },
    { id: 37, category: "STL", question: "Difference between reserve and resize?", options: ["No difference", "reserve changes capacity, resize changes size", "reserve is faster", "resize changes capacity"], correct: 1, explanation: "reserve only changes capacity, resize changes size" },
    { id: 38, category: "STL", question: "What is string's SSO?", options: ["Compressed string", "Small string stored in object", "Cached string", "Delayed allocation"], correct: 1, explanation: "Small strings stored inside object, avoiding heap" },
    { id: 39, category: "STL", question: "erase-remove idiom?", options: ["v.remove(x)", "v.erase(remove(...), end())", "std::erase(v, x)", "v.erase(x)"], correct: 1, explanation: "remove moves elements, erase actually deletes" },
    { id: 40, category: "STL", question: "vector insert in middle, iterators?", options: ["Not invalidated", "All invalidated", "After insert point invalid", "Only end() invalid"], correct: 2, explanation: "Middle insert invalidates from insert point onward" },
    { id: 41, category: "STL", question: "std::array vs C array advantage?", options: ["Variable size", "Supports STL algorithms, has size()", "Auto expansion", "Less memory"], correct: 1, explanation: "array supports STL algorithms and iterators" },
    { id: 42, category: "STL", question: "Time complexity of vector swap?", options: ["O(n)", "O(1)", "O(log n)", "O(n^2)"], correct: 1, explanation: "swap only exchanges internal pointers, O(1)" },
    { id: 43, category: "STL", question: "Can priority_queue elements be modified?", options: ["Yes", "No, need pop then re-push", "Only top", "Through iterator"], correct: 1, explanation: "No direct modification, need to extract and reinsert" },
    { id: 44, category: "STL", question: "stack.pop() return value?", options: ["Top element", "void", "bool", "New top"], correct: 1, explanation: "pop() returns void, use top() first to get value" },
    { id: 45, category: "STL", question: "unordered_set erase returns?", options: ["void", "Deleted element", "Next valid iterator", "bool"], correct: 2, explanation: "erase returns next valid iterator" },
    { id: 46, category: "STL", question: "set.lower_bound(key) returns?", options: ["First < key", "First >= key", "First > key", "First == key"], correct: 1, explanation: "lower_bound returns first >= key" },
    { id: 47, category: "STL", question: "map insert return value?", options: ["void", "iterator", "pair<iterator, bool>", "bool"], correct: 2, explanation: "Returns pair, bool indicates insertion success" },
    { id: 48, category: "STL", question: "emplace vs insert advantage?", options: ["Safer", "In-place construction, less copying", "Simpler", "Faster lookup"], correct: 1, explanation: "emplace constructs directly in container" },
    { id: 49, category: "STL", question: "std::array swap time complexity?", options: ["O(1)", "O(n)", "O(log n)", "O(n^2)"], correct: 1, explanation: "array is on stack, swap needs element-by-element" },
    { id: 50, category: "STL", question: "Does shrink_to_fit guarantee release?", options: ["Yes guaranteed", "No, just a hint", "Always fails", "Depends on element type"], correct: 1, explanation: "shrink_to_fit is a non-binding request" },
    { id: 51, category: "Functions", question: "When are virtual function defaults bound?", options: ["Runtime", "Compile time", "Link time", "Depends on call"], correct: 1, explanation: "Default arguments are bound at compile time" },
    { id: 52, category: "Functions", question: "Where is vtable usually located?", options: ["End of object", "Beginning of object", "Static area", "On heap"], correct: 1, explanation: "Usually vptr is at the beginning of object" },
    { id: 53, category: "Functions", question: "Does inline guarantee function inlining?", options: ["Yes", "No, just a suggestion", "Only in debug", "Depends on size"], correct: 1, explanation: "inline just allows multiple definitions + suggests" },
    { id: 54, category: "Functions", question: "Which overload match has priority?", options: ["Implicit conversion", "Exact match", "Template match", "Default parameter"], correct: 1, explanation: "Exact match prioritized → implicit conversion" },
    { id: 55, category: "Functions", question: "Both template and regular function match?", options: ["Function template", "Regular function", "Compilation error", "Random choice"], correct: 1, explanation: "Regular function has priority over template" },
    { id: 56, category: "Functions", question: "Template deduction: pass by value vs ref?", options: ["No difference", "Affects const and ref deduction", "Pass by value faster", "Pass by ref fails"], correct: 1, explanation: "Affects type deduction" },
    { id: 57, category: "Functions", question: "Main purpose of rvalue reference &&?", options: ["Logical AND", "Perfect forwarding and move", "Get address", "Type conversion"], correct: 1, explanation: "Used for perfect forwarding and move semantics" },
    { id: 58, category: "Functions", question: "What does explicit keyword do?", options: ["Export function", "Prevent implicit conversion", "Force inline", "Declare virtual"], correct: 1, explanation: "Prevents implicit conversion of constructors" },
    { id: 59, category: "Functions", question: "Difference between constexpr and const?", options: ["No difference", "constexpr must be compile-time", "const is faster", "constexpr only for functions"], correct: 1, explanation: "constexpr must be compile-time constant" },
    { id: 60, category: "Functions", question: "C++20 consteval characteristic?", options: ["Can be runtime", "Must be compile-time", "Same as constexpr", "Only returns void"], correct: 1, explanation: "consteval must be evaluated at compile time" },
    { id: 61, category: "Functions", question: "mutable member variable characteristic?", options: ["Cannot be modified", "Can modify in const object", "Must be static", "Must be initialized"], correct: 1, explanation: "mutable members can be modified in const functions" },
    { id: 62, category: "Functions", question: "What does [[nodiscard]] do?", options: ["Prevent discarding object", "Return value must be used", "No exceptions", "Mark deprecated"], correct: 1, explanation: "Requires caller to use return value" },
    { id: 63, category: "Functions", question: "What does [[maybe_unused]] do?", options: ["Mark must use", "Suppress unused warnings", "Delay initialization", "Optimization hint"], correct: 1, explanation: "Tells compiler variable may be unused" },
    { id: 64, category: "Functions", question: "std::function vs function pointer?", options: ["Faster", "Supports lambda with captures", "Less memory", "Simpler"], correct: 1, explanation: "function can wrap any callable object" },
    { id: 65, category: "Functions", question: "Lambda value vs reference capture?", options: ["No difference", "Value copies, ref needs lifetime care", "Reference faster", "Value can't modify"], correct: 1, explanation: "Value captures copy, reference needs lifetime care" },
    { id: 66, category: "Modern C++", question: "auto x = expr; preserves const and ref?", options: ["Yes", "No, cv-ref stripped", "Only const", "Only reference"], correct: 1, explanation: "auto copy deduction strips const and reference" },
    { id: 67, category: "Modern C++", question: "decltype(expr) preserves exact type?", options: ["No", "Yes, including ref and const", "Only basic type", "Depends on expression"], correct: 1, explanation: "decltype preserves exact type" },
    { id: 68, category: "Modern C++", question: "range-based for is essentially?", options: ["while loop", "Syntactic sugar for begin/end", "Recursion", "goto statement"], correct: 1, explanation: "Syntactic sugar calling begin() and end()" },
    { id: 69, category: "Modern C++", question: "nullptr vs NULL advantage?", options: ["Faster", "Type-safe, not treated as 0", "Less memory", "Better compatibility"], correct: 1, explanation: "nullptr is type-safe" },
    { id: 70, category: "Modern C++", question: "enum class vs enum advantage?", options: ["Faster", "Strong type, scoped", "Less memory", "Supports float"], correct: 1, explanation: "enum class is strongly typed enum" },
    { id: 71, category: "Modern C++", question: "What does std::move actually do?", options: ["Moves object", "Just casts to rvalue reference", "Copies object", "Deletes object"], correct: 1, explanation: "Just type conversion, real move in ctor/assignment" },
    { id: 72, category: "Modern C++", question: "What does std::forward do?", options: ["Forward declaration", "Perfect forward, preserves value category", "Loop iteration", "Type conversion"], correct: 1, explanation: "For perfect forwarding, preserves parameter attributes" },
    { id: 73, category: "Modern C++", question: "std::optional access when uninitialized?", options: ["Returns default", "Returns nullptr", "Throws exception", "Undefined behavior"], correct: 2, explanation: "Accessing empty optional throws exception" },
    { id: 74, category: "Modern C++", question: "std::variant vs union advantage?", options: ["Less memory", "Type-safe", "Faster", "Supports more types"], correct: 1, explanation: "variant is type-safe union" },
    { id: 75, category: "Modern C++", question: "structured bindings in which version?", options: ["C++11", "C++14", "C++17", "C++20"], correct: 2, explanation: "Structured bindings introduced in C++17" },
    { id: 76, category: "Modern C++", question: "What does if constexpr do?", options: ["Runtime condition", "Compile-time conditional branch", "Exception handling", "Type checking"], correct: 1, explanation: "if constexpr decides branch at compile time" },
    { id: 77, category: "Modern C++", question: "inline variables (C++17) solve?", options: ["Inline functions", "Header variables can be multiply included", "Constant folding", "Template instantiation"], correct: 1, explanation: "inline variables allow header file definitions" },
    { id: 78, category: "Modern C++", question: "C++20 concept is used for?", options: ["OOP", "Template constraints", "Memory management", "Concurrency"], correct: 1, explanation: "concept is used to constrain template parameters" },
    { id: 79, category: "Modern C++", question: "C++20 bit_cast vs reinterpret_cast?", options: ["Faster", "Type-safe, avoids aliasing UB", "More general", "Supports more types"], correct: 1, explanation: "bit_cast provides safe bit-level conversion" },
    { id: 80, category: "Modern C++", question: "C++20 coroutine keywords?", options: ["async/await", "co_await/co_yield/co_return", "yield/resume", "coroutine/suspend"], correct: 1, explanation: "Uses co_await, co_yield, co_return" },
    { id: 81, category: "Templates", question: "What does SFINAE stand for?", options: ["Standard Function...", "Substitution Failure Is Not An Error", "Static Function...", "Simple Format..."], correct: 1, explanation: "Substitution Failure Is Not An Error" },
    { id: 82, category: "Templates", question: "Partial vs full specialization difference?", options: ["No difference", "Partial matches some parameters", "Partial is faster", "Full only for classes"], correct: 1, explanation: "Partial specialization matches some template parameters" },
    { id: 83, category: "Templates", question: "Non-type template parameter can be?", options: ["Only int", "integral/pointer/reference etc", "Any type", "Only class types"], correct: 1, explanation: "Can be integral, pointer, reference, etc." },
    { id: 84, category: "Templates", question: "decltype(auto) vs auto difference?", options: ["No difference", "decltype(auto) preserves ref/const", "auto more precise", "decltype(auto) faster"], correct: 1, explanation: "decltype(auto) preserves exact type" },
    { id: 85, category: "Templates", question: "T&& in template may deduce to?", options: ["Only rvalue reference", "May be lvalue or rvalue reference", "Only lvalue reference", "Compilation error"], correct: 1, explanation: "T&& is forwarding reference, deduces to either" },
    { id: 86, category: "Templates", question: "What does sizeof...(Args) do?", options: ["Total bytes of args", "Number of args in pack", "Max arg size", "Syntax error"], correct: 1, explanation: "Returns number of parameters in pack" },
    { id: 87, category: "Templates", question: "fold expression in which version?", options: ["C++11", "C++14", "C++17", "C++20"], correct: 2, explanation: "Fold expressions introduced in C++17" },
    { id: 88, category: "Templates", question: "variadic templates allow?", options: ["Variable return type", "Variable number of template params", "Variable function name", "Variable scope"], correct: 1, explanation: "Allows accepting any number of template parameters" },
    { id: 89, category: "Templates", question: "What does std::enable_if do?", options: ["Enable function", "SFINAE template selection control", "Enable optimization", "Enable exceptions"], correct: 1, explanation: "Uses SFINAE to conditionally enable templates" },
    { id: 90, category: "Templates", question: "Which is NOT a type trait?", options: ["std::is_same", "std::is_base_of", "std::is_function", "std::is_allocated"], correct: 3, explanation: "std::is_allocated doesn't exist" },
    { id: 91, category: "Common UB", question: "signed integer overflow is?", options: ["Defined as wrap-around", "Undefined behavior (UB)", "Throws exception", "Returns max value"], correct: 1, explanation: "Signed integer overflow is UB" },
    { id: 92, category: "Common UB", question: "Accessing freed memory is?", options: ["Returns 0", "Undefined behavior (UB)", "Throws exception", "Program terminates"], correct: 1, explanation: "use-after-free is UB" },
    { id: 93, category: "Common UB", question: "Array out-of-bounds access is?", options: ["Returns default", "Undefined behavior (UB)", "Throws exception", "Auto expands"], correct: 1, explanation: "Array out-of-bounds access is UB" },
    { id: 94, category: "Common UB", question: "Using dangling pointer is?", options: ["Returns NULL", "Undefined behavior (UB)", "Compilation error", "Throws exception"], correct: 1, explanation: "Dangling pointer use is UB" },
    { id: 95, category: "Common UB", question: "Violating strict aliasing is?", options: ["Performance drop", "Undefined behavior (UB)", "Compiler warning", "Type conversion"], correct: 1, explanation: "Violating strict aliasing is UB" },
    { id: 96, category: "Common UB", question: "Multi-threaded data race is?", options: ["Program slows down", "Undefined behavior (UB)", "Deadlock", "Result undefined but defined behavior"], correct: 1, explanation: "data race is UB" },
    { id: 97, category: "Common UB", question: "Left shift count >= type width is?", options: ["Result is 0", "Undefined behavior (UB)", "Circular shift", "Compilation error"], correct: 1, explanation: "Shift count >= width is UB" },
    { id: 98, category: "Common UB", question: "Using invalidated iterator is?", options: ["Returns end()", "Undefined behavior (UB)", "Throws exception", "Auto updates"], correct: 1, explanation: "Using invalidated iterator is UB" },
    { id: 99, category: "Common UB", question: "Returning pointer to local object is?", options: ["Returns copy", "Undefined behavior (UB)", "Compilation error", "Returns NULL"], correct: 1, explanation: "Returning local pointer/reference is UB" },
    { id: 100, category: "Common UB", question: "Multiple unsequenced modifications?", options: ["Left-to-right evaluation", "Undefined behavior (UB)", "Compilation error", "Random result"], correct: 1, explanation: "e.g., i = i++ + ++i is UB" }
];

function getRandomQuestions(count) {
    return [...allQuestions].sort(() => Math.random() - 0.5).slice(0, count);
}

let gameState = { questions: [], currentIndex: 0, score: 0, answers: [], totalQuestions: 20 };

// Detect mobile
const isMobile = window.innerWidth <= 768;
const GAME_WIDTH = isMobile ? window.innerWidth : 800;
const GAME_HEIGHT = isMobile ? window.innerHeight : 650;

// Font sizes - different for mobile and desktop
const FONT = {
    title: isMobile ? 52 : 56,
    subtitle: isMobile ? 32 : 32,
    info: isMobile ? 20 : 18,
    category: isMobile ? 18 : 15,
    question: isMobile ? 22 : 20,
    option: isMobile ? 20 : 17,
    optionLabel: isMobile ? 22 : 18,
    button: isMobile ? 24 : 22,
    explanation: isMobile ? 18 : 15,
    score: isMobile ? 64 : 64,
    percent: isMobile ? 28 : 26,
    review: isMobile ? 16 : 14,
    reviewSmall: isMobile ? 14 : 12
};

class BootScene extends Phaser.Scene {
    constructor() { super({ key: 'BootScene' }); }
    create() {
        document.getElementById('loading').style.display = 'none';
        this.scene.start('MenuScene');
    }
}

class MenuScene extends Phaser.Scene {
    constructor() { super({ key: 'MenuScene' }); }

    create() {
        const { width, height } = this.cameras.main;
        this.createBg();

        const title = this.add.text(width / 2, height * 0.15, 'C++ Trivials', {
            fontSize: FONT.title + 'px', fontFamily: 'Arial Black', color: '#00d4ff', stroke: '#0066cc', strokeThickness: 4
        }).setOrigin(0.5);
        this.tweens.add({ targets: title, alpha: 0.8, duration: 1500, yoyo: true, repeat: -1 });

        this.add.text(width / 2, height * 0.26, 'Quiz Game', {
            fontSize: FONT.subtitle + 'px', fontFamily: 'Arial', color: '#fff'
        }).setOrigin(0.5);

        this.add.text(width / 2, height * 0.38, '100 C++ Knowledge Points\nRandom 20 Questions Per Game', {
            fontSize: FONT.info + 'px', fontFamily: 'Arial', color: '#888', align: 'center', lineSpacing: 6
        }).setOrigin(0.5);

        const cats = ['Types & Expressions', 'Memory Management', 'STL Containers', 'Functions', 'C++11-20 Features', 'Templates', 'Common UB'];
        const startY = height * 0.50;
        cats.forEach((c, i) => {
            this.add.text(width / 2, startY + i * (isMobile ? 28 : 24), c, {
                fontSize: FONT.category + 'px', fontFamily: 'Arial', color: '#4a9eff'
            }).setOrigin(0.5);
        });

        this.createBtn(width / 2, height * 0.88, 'Start Game', () => {
            gameState = { questions: getRandomQuestions(20), currentIndex: 0, score: 0, answers: [], totalQuestions: 20 };
            this.cameras.main.fadeOut(400);
            this.time.delayedCall(400, () => this.scene.start('GameScene'));
        });

        this.createParticles();
    }

    createBg() {
        const { width, height } = this.cameras.main;
        const g = this.add.graphics();
        for (let i = 0; i < height; i++) {
            const r = i / height;
            g.fillStyle(Phaser.Display.Color.GetColor(26 + r * 10, 26 + r * 15, 46 + r * 20));
            g.fillRect(0, i, width, 1);
        }
        for (let i = 0; i < 5; i++) this.add.circle(Phaser.Math.Between(0, width), Phaser.Math.Between(0, height), Phaser.Math.Between(40, 120), 0x4a9eff, 0.03);
    }

    createBtn(x, y, text, cb) {
        const bw = isMobile ? 220 : 200, bh = isMobile ? 56 : 50;
        const c = this.add.container(x, y);
        const bg = this.add.graphics();
        bg.fillStyle(0x4a9eff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 12);
        c.add([bg, this.add.text(0, 0, text, { fontSize: FONT.button + 'px', fontFamily: 'Arial', color: '#fff' }).setOrigin(0.5)]);
        c.setSize(bw, bh).setInteractive({ useHandCursor: true });
        c.on('pointerover', () => { bg.clear().fillStyle(0x6ab4ff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 12); });
        c.on('pointerout', () => { bg.clear().fillStyle(0x4a9eff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 12); });
        c.on('pointerdown', cb);
    }

    createParticles() {
        const { width, height } = this.cameras.main;
        for (let i = 0; i < 15; i++) {
            const p = this.add.circle(Phaser.Math.Between(0, width), Phaser.Math.Between(0, height), Phaser.Math.Between(2, 4), 0x4a9eff, 0.5);
            this.tweens.add({ targets: p, y: p.y - 100, alpha: 0, duration: Phaser.Math.Between(3000, 5000), repeat: -1,
                onRepeat: () => { p.x = Phaser.Math.Between(0, width); p.y = height + 20; p.alpha = 0.5; }
            });
        }
    }
}

class GameScene extends Phaser.Scene {
    constructor() { super({ key: 'GameScene' }); this.btns = []; this.canAnswer = true; }

    create() {
        const { width, height } = this.cameras.main;
        this.cameras.main.fadeIn(400);
        this.createBg();

        const barY = height * 0.03, barH = isMobile ? 18 : 16;
        this.add.graphics().fillStyle(0x333355, 1).fillRoundedRect(20, barY, width - 40, barH, 8);
        this.progressBar = this.add.graphics();

        const infoY = barY + barH + 8;
        this.numTxt = this.add.text(20, infoY, '', { fontSize: FONT.info + 'px', fontFamily: 'Arial', color: '#888' });
        this.scoreTxt = this.add.text(width - 20, infoY, '', { fontSize: FONT.info + 'px', fontFamily: 'Arial', color: '#4a9eff' }).setOrigin(1, 0);
        this.catTxt = this.add.text(width / 2, infoY + (isMobile ? 30 : 26), '', { fontSize: FONT.category + 'px', fontFamily: 'Arial', color: '#666' }).setOrigin(0.5);

        const qY = height * 0.15, qH = height * 0.20;
        this.add.graphics().fillStyle(0x252540, 0.9).fillRoundedRect(15, qY, width - 30, qH, 12);
        this.qTxt = this.add.text(width / 2, qY + qH / 2, '', {
            fontSize: FONT.question + 'px', fontFamily: 'Arial', color: '#fff', wordWrap: { width: width - 50 }, align: 'center', lineSpacing: 4
        }).setOrigin(0.5);

        this.createOptions();

        const expY = height * 0.92;
        this.expC = this.add.container(width / 2, expY).setVisible(false);
        const expBg = this.add.graphics().fillStyle(0x333355, 0.9).fillRoundedRect(-(width/2 - 15), -22, width - 30, 44, 8);
        this.expTxt = this.add.text(0, 0, '', { fontSize: FONT.explanation + 'px', fontFamily: 'Arial', color: '#aaa', wordWrap: { width: width - 50 }, align: 'center' }).setOrigin(0.5);
        this.expC.add([expBg, this.expTxt]);

        this.showQ();
    }

    createBg() {
        const { width, height } = this.cameras.main;
        const g = this.add.graphics();
        for (let i = 0; i < height; i++) {
            const r = i / height;
            g.fillStyle(Phaser.Display.Color.GetColor(26 + r * 10, 26 + r * 15, 46 + r * 20));
            g.fillRect(0, i, width, 1);
        }
    }

    createOptions() {
        const { width, height } = this.cameras.main;
        const startY = height * 0.38, spacing = height * 0.13;
        const bw = width - 30, bh = isMobile ? 58 : 50;
        this.btns = [];

        for (let i = 0; i < 4; i++) {
            const y = startY + i * spacing;
            const c = this.add.container(width / 2, y);
            const bg = this.add.graphics().fillStyle(0x2a2a4a, 1).lineStyle(2, 0x4a9eff, 0.5)
                .fillRoundedRect(-bw/2, -bh/2, bw, bh, 10).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 10);
            const lbl = this.add.text(-bw/2 + 15, 0, String.fromCharCode(65 + i) + '.', {
                fontSize: FONT.optionLabel + 'px', fontFamily: 'Arial Black', color: '#4a9eff'
            }).setOrigin(0, 0.5);
            const txt = this.add.text(-bw/2 + (isMobile ? 50 : 45), 0, '', {
                fontSize: FONT.option + 'px', fontFamily: 'Arial', color: '#fff', wordWrap: { width: bw - 70 }
            }).setOrigin(0, 0.5);

            c.add([bg, lbl, txt]).setSize(bw, bh).setInteractive({ useHandCursor: true });
            c.bg = bg; c.txt = txt; c.lbl = lbl; c.bw = bw; c.bh = bh; c.idx = i;

            c.on('pointerover', () => { if (!this.canAnswer) return; bg.clear().fillStyle(0x3a3a5a, 1).lineStyle(2, 0x6ab4ff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 10); });
            c.on('pointerout', () => { if (!this.canAnswer) return; bg.clear().fillStyle(0x2a2a4a, 1).lineStyle(2, 0x4a9eff, 0.5).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 10); });
            c.on('pointerdown', () => { if (this.canAnswer) this.answer(i); });

            this.btns.push(c);
        }
    }

    showQ() {
        const { width, height } = this.cameras.main;
        const q = gameState.questions[gameState.currentIndex];
        const barY = height * 0.03, barH = isMobile ? 18 : 16;

        const prog = gameState.currentIndex / gameState.totalQuestions;
        this.progressBar.clear().fillStyle(0x4a9eff, 1);
        if (prog > 0) this.progressBar.fillRoundedRect(20, barY, (width - 40) * prog, barH, 8);

        this.numTxt.setText(`${gameState.currentIndex + 1}/${gameState.totalQuestions}`);
        this.scoreTxt.setText(`Score: ${gameState.score}`);
        this.catTxt.setText(q.category);
        this.qTxt.setText(q.question);

        this.canAnswer = true;
        this.expC.setVisible(false);

        this.btns.forEach((b, i) => {
            const { bw, bh } = b;
            b.txt.setText(q.options[i]);
            b.setAlpha(0).x = width / 2 + 30;
            b.bg.clear().fillStyle(0x2a2a4a, 1).lineStyle(2, 0x4a9eff, 0.5).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 10);
            b.lbl.setColor('#4a9eff');
            b.txt.setColor('#fff');
            this.tweens.add({ targets: b, alpha: 1, x: width / 2, duration: 200, delay: i * 50, ease: 'Back.easeOut' });
        });
    }

    answer(idx) {
        this.canAnswer = false;
        const q = gameState.questions[gameState.currentIndex];
        const ok = idx === q.correct;
        gameState.answers.push({ question: q, selected: idx, correct: ok });
        if (ok) { gameState.score++; this.scoreTxt.setText(`Score: ${gameState.score}`); }

        this.btns.forEach((b, i) => {
            const { bw, bh } = b;
            if (i === q.correct) {
                b.bg.clear().fillStyle(0x2a5a2a, 1).lineStyle(3, 0x4aff4a, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 10);
                b.lbl.setColor('#4aff4a');
                if (ok) this.burst(b.x, b.y);
            } else if (i === idx) {
                b.bg.clear().fillStyle(0x5a2a2a, 1).lineStyle(3, 0xff4a4a, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10).strokeRoundedRect(-bw/2, -bh/2, bw, bh, 10);
                b.lbl.setColor('#ff4a4a'); b.txt.setColor('#ff8888');
                this.tweens.add({ targets: b, x: b.x + 8, duration: 40, yoyo: true, repeat: 3 });
            } else {
                b.setAlpha(0.4);
            }
        });

        this.expTxt.setText(q.explanation);
        this.expC.setVisible(true).setAlpha(0);
        this.tweens.add({ targets: this.expC, alpha: 1, duration: 200 });
        this.time.delayedCall(1600, () => this.next());
    }

    burst(x, y) {
        for (let i = 0; i < 8; i++) {
            const a = (i / 8) * Math.PI * 2;
            const p = this.add.circle(x, y, 5, 0x4aff4a);
            this.tweens.add({ targets: p, x: x + Math.cos(a) * 50, y: y + Math.sin(a) * 25, alpha: 0, scale: 0, duration: 350, onComplete: () => p.destroy() });
        }
    }

    next() {
        gameState.currentIndex++;
        if (gameState.currentIndex >= gameState.totalQuestions) {
            this.cameras.main.fadeOut(400);
            this.time.delayedCall(400, () => this.scene.start('ResultScene'));
        } else {
            this.btns.forEach((b, i) => {
                this.tweens.add({ targets: b, x: -100, alpha: 0, duration: 120, delay: i * 30, onComplete: () => { if (i === 3) this.showQ(); } });
            });
        }
    }
}

class ResultScene extends Phaser.Scene {
    constructor() { super({ key: 'ResultScene' }); }

    create() {
        const { width, height } = this.cameras.main;
        this.cameras.main.fadeIn(400);
        this.createBg();

        const pct = Math.round((gameState.score / gameState.totalQuestions) * 100);
        let title, color;
        if (pct >= 90) { title = 'Excellent!'; color = '#4aff4a'; }
        else if (pct >= 70) { title = 'Great Job!'; color = '#4a9eff'; }
        else if (pct >= 50) { title = 'Good Try!'; color = '#ffaa4a'; }
        else { title = 'Keep Learning!'; color = '#ff6a6a'; }

        this.add.text(width / 2, height * 0.12, title, { fontSize: (isMobile ? 44 : 42) + 'px', fontFamily: 'Arial Black', color }).setOrigin(0.5);

        this.scoreDisp = this.add.text(width / 2, height * 0.26, '0', { fontSize: FONT.score + 'px', fontFamily: 'Arial Black', color: '#fff' }).setOrigin(0.5);
        this.add.text(width / 2, height * 0.34, `out of ${gameState.totalQuestions}`, { fontSize: (isMobile ? 22 : 20) + 'px', fontFamily: 'Arial', color: '#888' }).setOrigin(0.5);

        let disp = 0;
        this.time.addEvent({ delay: 40, repeat: gameState.score, callback: () => { disp++; this.scoreDisp.setText(disp.toString()); } });

        this.drawCircle(width / 2, height * 0.50, pct);

        const correct = gameState.answers.filter(a => a.correct).length;
        const wrong = gameState.totalQuestions - correct;
        this.add.text(width / 2 - 60, height * 0.66, `Correct: ${correct}`, { fontSize: (isMobile ? 20 : 18) + 'px', fontFamily: 'Arial', color: '#4aff4a' }).setOrigin(0.5);
        this.add.text(width / 2 + 60, height * 0.66, `Wrong: ${wrong}`, { fontSize: (isMobile ? 20 : 18) + 'px', fontFamily: 'Arial', color: '#ff6a6a' }).setOrigin(0.5);

        const btnY = height * 0.80;
        this.createBtn(width / 2 - 75, btnY, 'Again', () => { this.cameras.main.fadeOut(400); this.time.delayedCall(400, () => this.scene.start('MenuScene')); });
        this.createBtn(width / 2 + 75, btnY, 'Review', () => this.showReview());

        if (pct >= 70) this.confetti();
    }

    createBg() {
        const { width, height } = this.cameras.main;
        const g = this.add.graphics();
        for (let i = 0; i < height; i++) {
            const r = i / height;
            g.fillStyle(Phaser.Display.Color.GetColor(26 + r * 10, 26 + r * 15, 46 + r * 20));
            g.fillRect(0, i, width, 1);
        }
    }

    drawCircle(x, y, pct) {
        const rad = isMobile ? 55 : 50;
        this.add.graphics().lineStyle(8, 0x333355, 1).arc(x, y, rad, 0, Math.PI * 2).strokePath();
        const pg = this.add.graphics();
        const col = pct >= 70 ? 0x4aff4a : pct >= 50 ? 0xffaa4a : 0xff6a6a;
        this.tweens.addCounter({
            from: -Math.PI / 2, to: -Math.PI / 2 + (pct / 100) * Math.PI * 2, duration: 700,
            onUpdate: t => { pg.clear().lineStyle(8, col, 1).beginPath().arc(x, y, rad, -Math.PI / 2, t.getValue()).strokePath(); }
        });
        this.add.text(x, y, pct + '%', { fontSize: FONT.percent + 'px', fontFamily: 'Arial Black', color: '#fff' }).setOrigin(0.5);
    }

    createBtn(x, y, text, cb) {
        const bw = isMobile ? 130 : 110, bh = isMobile ? 48 : 42;
        const c = this.add.container(x, y);
        const bg = this.add.graphics().fillStyle(0x4a9eff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10);
        c.add([bg, this.add.text(0, 0, text, { fontSize: (isMobile ? 20 : 18) + 'px', fontFamily: 'Arial', color: '#fff' }).setOrigin(0.5)]);
        c.setSize(bw, bh).setInteractive({ useHandCursor: true });
        c.on('pointerover', () => bg.clear().fillStyle(0x6ab4ff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10));
        c.on('pointerout', () => bg.clear().fillStyle(0x4a9eff, 1).fillRoundedRect(-bw/2, -bh/2, bw, bh, 10));
        c.on('pointerdown', cb);
    }

    confetti() {
        const { width, height } = this.cameras.main;
        const cols = [0x4aff4a, 0x4a9eff, 0xffaa4a, 0xff6aff, 0xffff4a];
        for (let i = 0; i < 20; i++) {
            const px = Phaser.Math.Between(0, width);
            const p = this.add.rectangle(px, -10, 6, 6, Phaser.Utils.Array.GetRandom(cols)).setRotation(Math.PI / 4);
            this.tweens.add({ targets: p, y: height + 30, x: px + Phaser.Math.Between(-60, 60), rotation: p.rotation + Math.PI * 2, duration: Phaser.Math.Between(1500, 2500), delay: Phaser.Math.Between(0, 1000), repeat: -1 });
        }
    }

    showReview() {
        this.children.removeAll();
        const { width, height } = this.cameras.main;
        this.createBg();

        this.add.text(width / 2, 22, 'Review', { fontSize: (isMobile ? 28 : 26) + 'px', fontFamily: 'Arial Black', color: '#4a9eff' }).setOrigin(0.5);

        let scrollY = 0;
        const itemH = isMobile ? 105 : 90;
        const contentH = gameState.answers.length * itemH + 60;
        const cont = this.add.container(0, 50);

        gameState.answers.forEach((a, i) => {
            const y = i * itemH;
            const ok = a.correct;
            cont.add(this.add.graphics().fillStyle(ok ? 0x2a4a2a : 0x4a2a2a, 0.8).fillRoundedRect(10, y, width - 20, itemH - 8, 8));
            cont.add(this.add.text(18, y + 6, `${i + 1}. ${ok ? '\u2713' : '\u2717'}`, { fontSize: FONT.review + 'px', fontFamily: 'Arial Black', color: ok ? '#4aff4a' : '#ff6a6a' }));
            cont.add(this.add.text(18, y + 28, a.question.question, { fontSize: FONT.review + 'px', fontFamily: 'Arial', color: '#fff', wordWrap: { width: width - 36 } }));
            const ans = a.question.options[a.question.correct];
            if (!ok) {
                cont.add(this.add.text(18, y + 54, `Your: ${a.question.options[a.selected]}`, { fontSize: FONT.reviewSmall + 'px', fontFamily: 'Arial', color: '#ff8888' }));
                cont.add(this.add.text(18, y + 72, `Correct: ${ans}`, { fontSize: FONT.reviewSmall + 'px', fontFamily: 'Arial', color: '#88ff88' }));
            } else {
                cont.add(this.add.text(18, y + 58, `Answer: ${ans}`, { fontSize: FONT.reviewSmall + 'px', fontFamily: 'Arial', color: '#88ff88' }));
            }
        });

        this.input.on('wheel', (p, g, dx, dy) => {
            scrollY = Phaser.Math.Clamp(scrollY - dy * 0.5, -(contentH - height + 100), 0);
            cont.y = 50 + scrollY;
        });

        let startY = 0, startScroll = 0;
        this.input.on('pointerdown', p => { startY = p.y; startScroll = scrollY; });
        this.input.on('pointermove', p => {
            if (p.isDown) {
                scrollY = Phaser.Math.Clamp(startScroll + (p.y - startY), -(contentH - height + 100), 0);
                cont.y = 50 + scrollY;
            }
        });

        this.createBtn(width / 2, height - 32, 'Back', () => { this.cameras.main.fadeOut(400); this.time.delayedCall(400, () => this.scene.start('MenuScene')); });
    }
}

const config = {
    type: Phaser.AUTO,
    width: GAME_WIDTH,
    height: GAME_HEIGHT,
    parent: 'game-container',
    backgroundColor: '#1a1a2e',
    scene: [BootScene, MenuScene, GameScene, ResultScene],
    scale: isMobile ? { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH } : { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH }
};

new Phaser.Game(config);
    </script>
</body>
</html>
