<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>C++ Trivials Quiz Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #game-container canvas {
            display: block;
        }

        #game-container {
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #4a9eff;
            font-size: 24px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(74, 158, 255, 0.3);
            border-top-color: #4a9eff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        Loading...
    </div>
    <div id="game-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <script>
// ==================== Questions Data ====================
const allQuestions = [
    { id: 1, category: "基础类型", question: "sizeof('a') 在 C++ 中是多少？", options: ["1（char类型）", "4（int类型）", "2（short类型）", "取决于编译器"], correct: 0, explanation: "C中是int(4)，C++中是char(1)" },
    { id: 2, category: "基础类型", question: "char 默认是 signed 还是 unsigned？", options: ["signed", "unsigned", "implementation-defined", "总是 signed char"], correct: 2, explanation: "implementation-defined，最好显式声明" },
    { id: 3, category: "基础类型", question: "-1 < 1u 的结果是什么？", options: ["true", "false", "编译错误", "未定义行为"], correct: 1, explanation: "-1 转成 unsigned 后变成极大正数" },
    { id: 4, category: "基础类型", question: "uint8_t + uint8_t 的结果类型是？", options: ["uint8_t", "uint16_t", "int（整型提升）", "unsigned int"], correct: 2, explanation: "整型提升会将小整数类型提升为int" },
    { id: 5, category: "基础类型", question: "在C++17前，1 << 31 是什么行为？", options: ["等于 INT_MIN", "等于 0", "未定义行为(UB)", "编译错误"], correct: 2, explanation: "signed int 左移溢出是UB" },
    { id: 6, category: "基础类型", question: "0.1 + 0.2 == 0.3 的结果？", options: ["true", "false", "编译错误", "取决于编译器"], correct: 1, explanation: "浮点精度问题导致不相等" },
    { id: 7, category: "基础类型", question: "int a=1; a=a++ + ++a; 结果？", options: ["4", "5", "3", "未定义行为(UB)"], correct: 3, explanation: "多次修改同一变量无序点是UB" },
    { id: 8, category: "基础类型", question: "nullptr 的类型是什么？", options: ["void*", "int", "std::nullptr_t", "NULL"], correct: 2, explanation: "std::nullptr_t，可隐式转换成任意指针" },
    { id: 9, category: "基础类型", question: "sizeof(bool) 的值是？", options: ["总是 1", "总是 4", "implementation-defined", "总是 0"], correct: 2, explanation: "implementation-defined，通常是1字节" },
    { id: 10, category: "基础类型", question: "0xFFFFFFFF 在 signed 32位 int 中是？", options: ["4294967295", "-1", "0", "溢出错误"], correct: 1, explanation: "signed是-1；unsigned是4294967295" },
    { id: 11, category: "基础类型", question: "true + true 的结果？", options: ["true", "2", "编译错误", "未定义行为"], correct: 1, explanation: "布尔值参与整数运算，true被提升为1" },
    { id: 12, category: "基础类型", question: "signed char c = 255; c的值是？", options: ["255", "-1", "0", "未定义行为"], correct: 1, explanation: "signed char范围是-128到127，溢出变-1" },
    { id: 13, category: "基础类型", question: "int* p = 0 与 nullptr 的区别？", options: ["功能不同", "nullptr类型安全", "0更快", "没有区别"], correct: 1, explanation: "nullptr类型安全，不会被误解为整数" },
    { id: 14, category: "基础类型", question: "auto x = {1, 2}; x 的类型？", options: ["int[]", "vector<int>", "initializer_list<int>", "array<int,2>"], correct: 2, explanation: "花括号初始化推导为initializer_list" },
    { id: 15, category: "基础类型", question: "const int* p 表示什么？", options: ["指针是常量", "被指对象是常量", "两者都是常量", "语法错误"], correct: 1, explanation: "const修饰左边→被指向对象const" },
    { id: 16, category: "内存管理", question: "malloc 和 new 的主要区别？", options: ["没有区别", "malloc不调构造函数", "new不分配内存", "malloc更快"], correct: 1, explanation: "malloc只分配内存不调用构造函数" },
    { id: 17, category: "内存管理", question: "new[] 分配，用 delete 释放？", options: ["正常释放", "未定义行为(UB)", "编译错误", "只释放第一个"], correct: 1, explanation: "delete和delete[]必须匹配" },
    { id: 18, category: "内存管理", question: "返回局部变量的引用会怎样？", options: ["正常工作", "编译错误", "未定义行为(UB)", "返回副本"], correct: 2, explanation: "函数返回后栈空间释放，是UB" },
    { id: 19, category: "内存管理", question: "placement new 的作用？", options: ["分配更大内存", "在已分配内存上构造", "自动释放内存", "创建多个对象"], correct: 1, explanation: "在已分配的内存上构造对象" },
    { id: 20, category: "内存管理", question: "memset 初始化 std::string？", options: ["正常工作", "未定义行为(UB)", "编译错误", "字符串变空"], correct: 1, explanation: "memset只能用在trivial对象上" },
    { id: 21, category: "内存管理", question: "空类(class Empty{};)大小？", options: ["0", "1", "4", "8"], correct: 1, explanation: "1字节，保证每个对象地址不同" },
    { id: 22, category: "内存管理", question: "析构函数调用顺序？", options: ["基类→派生类", "派生类→基类", "同时调用", "只调用派生类"], correct: 1, explanation: "析构顺序是派生类→基类" },
    { id: 23, category: "内存管理", question: "不同翻译单元静态对象销毁顺序？", options: ["按声明顺序", "按字母顺序", "不确定", "同时销毁"], correct: 2, explanation: "不同翻译单元顺序不确定" },
    { id: 24, category: "内存管理", question: "volatile 能保证线程安全吗？", options: ["能", "不能", "部分平台能", "取决于编译器"], correct: 1, explanation: "volatile只禁止优化，不保证线程安全" },
    { id: 25, category: "内存管理", question: "delete后再访问是什么行为？", options: ["返回默认值", "未定义行为(UB)", "抛出异常", "返回NULL"], correct: 1, explanation: "use-after-free是未定义行为" },
    { id: 26, category: "内存管理", question: "什么是悬垂引用？", options: ["空引用", "引用已释放对象", "const引用", "临时引用"], correct: 1, explanation: "引用绑定已释放对象→悬垂引用" },
    { id: 27, category: "内存管理", question: "关于引用，哪项正确？", options: ["可以不初始化", "必须初始化", "可以重新绑定", "可以为null"], correct: 1, explanation: "引用必须在声明时初始化" },
    { id: 28, category: "内存管理", question: "移动语义的优势？", options: ["更安全", "窃取资源避免拷贝", "代码更简洁", "兼容性更好"], correct: 1, explanation: "移动语义避免不必要的深拷贝" },
    { id: 29, category: "内存管理", question: "拷贝构造和拷贝赋值的区别？", options: ["没有区别", "构造新对象vs赋值已有", "一个用=一个用()", "效率不同"], correct: 1, explanation: "拷贝构造创建新对象，拷贝赋值给已存在对象" },
    { id: 30, category: "内存管理", question: "T t; 和 T t{}; 的区别？", options: ["没有区别", "default vs value初始化", "语法糖", "编译器优化"], correct: 1, explanation: "T t;是default，T t{};是value初始化" },
    { id: 31, category: "STL容器", question: "vector push_back 会失效什么？", options: ["只有iterator", "iterator/pointer/reference都可能", "不会失效", "只有reference"], correct: 1, explanation: "重新分配内存时全部可能失效" },
    { id: 32, category: "STL容器", question: "deque 两端插入时什么失效？", options: ["都不失效", "iterator失效，reference不失效", "全部失效", "只有pointer"], correct: 1, explanation: "两端插入时Iterator失效，Reference不失效" },
    { id: 33, category: "STL容器", question: "list 插入时迭代器是否失效？", options: ["会失效", "不失效（除被删节点）", "部分失效", "取决于位置"], correct: 1, explanation: "list是链表，插入不影响其他迭代器" },
    { id: 34, category: "STL容器", question: "map operator[] 访问不存在key？", options: ["抛出异常", "返回默认值", "插入默认值", "返回end()"], correct: 2, explanation: "operator[]会插入一个默认值元素" },
    { id: 35, category: "STL容器", question: "map find 和 operator[] 区别？", options: ["没有区别", "find不插入，[]会插入", "find更快", "[]更安全"], correct: 1, explanation: "find不存在返回end()，不插入" },
    { id: 36, category: "STL容器", question: "unordered_map 迭代顺序？", options: ["按key排序", "按插入顺序", "不稳定/不确定", "按hash排序"], correct: 2, explanation: "基于哈希表，迭代顺序不稳定" },
    { id: 37, category: "STL容器", question: "vector reserve 和 resize 区别？", options: ["没有区别", "reserve改capacity，resize改size", "reserve更快", "resize改capacity"], correct: 1, explanation: "reserve只改capacity，resize改size" },
    { id: 38, category: "STL容器", question: "string 的 SSO 是什么？", options: ["压缩字符串", "小字符串存对象内部", "缓存字符串", "延迟分配"], correct: 1, explanation: "小字符串存对象内部，避免堆分配" },
    { id: 39, category: "STL容器", question: "erase-remove 惯用法？", options: ["v.remove(x)", "v.erase(remove(...), end())", "std::erase(v, x)", "v.erase(x)"], correct: 1, explanation: "remove移动元素，erase真正删除" },
    { id: 40, category: "STL容器", question: "vector 中间插入，迭代器？", options: ["不失效", "全部失效", "插入点之后失效", "只有end()失效"], correct: 2, explanation: "中间插入导致插入点之后失效" },
    { id: 41, category: "STL容器", question: "std::array vs C数组优势？", options: ["大小可变", "支持STL算法，有size()", "自动扩容", "更省内存"], correct: 1, explanation: "array支持STL算法和迭代器" },
    { id: 42, category: "STL容器", question: "vector swap 的时间复杂度？", options: ["O(n)", "O(1)", "O(log n)", "O(n^2)"], correct: 1, explanation: "swap只交换内部指针，是O(1)" },
    { id: 43, category: "STL容器", question: "priority_queue 能直接修改元素？", options: ["能", "不能，需pop后重新push", "只能修改top", "可以通过迭代器"], correct: 1, explanation: "不支持直接修改，需要取出后重新插入" },
    { id: 44, category: "STL容器", question: "stack.pop() 返回值？", options: ["栈顶元素", "void", "bool", "新的栈顶"], correct: 1, explanation: "pop()返回void，需先用top()获取" },
    { id: 45, category: "STL容器", question: "unordered_set erase 返回？", options: ["void", "被删除元素", "下一个有效iterator", "bool"], correct: 2, explanation: "erase返回下一个有效iterator" },
    { id: 46, category: "STL容器", question: "set.lower_bound(key) 返回？", options: ["第一个 < key", "第一个 >= key", "第一个 > key", "第一个 == key"], correct: 1, explanation: "lower_bound返回>=key的第一个" },
    { id: 47, category: "STL容器", question: "map insert 返回值？", options: ["void", "iterator", "pair<iterator, bool>", "bool"], correct: 2, explanation: "返回pair，bool表示是否成功插入" },
    { id: 48, category: "STL容器", question: "emplace vs insert 优势？", options: ["更安全", "原地构造，减少拷贝", "更简洁", "更快查找"], correct: 1, explanation: "emplace直接在容器内构造元素" },
    { id: 49, category: "STL容器", question: "std::array swap 时间复杂度？", options: ["O(1)", "O(n)", "O(log n)", "O(n^2)"], correct: 1, explanation: "array在栈上，swap需逐元素交换" },
    { id: 50, category: "STL容器", question: "vector shrink_to_fit 保证释放？", options: ["能保证", "不能保证，只是提示", "总是失败", "取决于元素类型"], correct: 1, explanation: "shrink_to_fit是非强制的建议" },
    { id: 51, category: "函数调用", question: "虚函数默认参数何时绑定？", options: ["运行时", "编译期", "链接期", "取决于调用方式"], correct: 1, explanation: "默认参数在编译期绑定" },
    { id: 52, category: "函数调用", question: "vtable 通常在对象什么位置？", options: ["对象末尾", "对象开头", "静态区域", "堆上"], correct: 1, explanation: "通常在对象开头存放vptr" },
    { id: 53, category: "函数调用", question: "inline 能保证函数内联吗？", options: ["能保证", "不能保证，只是建议", "只在debug生效", "取决于大小"], correct: 1, explanation: "inline只是允许多定义+建议" },
    { id: 54, category: "函数调用", question: "函数重载时哪种匹配优先？", options: ["隐式转换", "精确匹配", "模板匹配", "默认参数"], correct: 1, explanation: "精确匹配优先→隐式转换" },
    { id: 55, category: "函数调用", question: "函数模板和普通函数都能匹配？", options: ["函数模板", "普通函数", "编译错误", "随机选择"], correct: 1, explanation: "普通函数比模板优先匹配" },
    { id: 56, category: "函数调用", question: "模板推导时传值和传引用区别？", options: ["没有区别", "影响const和引用推导", "传值更快", "传引用会失败"], correct: 1, explanation: "会影响类型推导" },
    { id: 57, category: "函数调用", question: "右值引用 && 的主要用途？", options: ["逻辑与运算", "完美转发和移动语义", "取地址", "类型转换"], correct: 1, explanation: "用于完美转发、move语义" },
    { id: 58, category: "函数调用", question: "explicit 关键字作用？", options: ["导出函数", "禁止隐式类型转换", "强制内联", "声明虚函数"], correct: 1, explanation: "禁止构造函数的隐式转换" },
    { id: 59, category: "函数调用", question: "constexpr 和 const 区别？", options: ["没有区别", "constexpr必须编译期", "const更快", "constexpr只用于函数"], correct: 1, explanation: "constexpr必须是编译期常量" },
    { id: 60, category: "函数调用", question: "C++20 consteval 特点？", options: ["可以运行期求值", "必须编译期求值", "等同constexpr", "只能返回void"], correct: 1, explanation: "consteval必须在编译期求值" },
    { id: 61, category: "函数调用", question: "mutable 成员变量特点？", options: ["不能被修改", "const对象也能修改", "只能是static", "必须初始化"], correct: 1, explanation: "mutable成员可在const函数中修改" },
    { id: 62, category: "函数调用", question: "[[nodiscard]] 属性作用？", options: ["禁止丢弃对象", "返回值必须使用", "不能抛异常", "标记废弃"], correct: 1, explanation: "要求调用者使用返回值" },
    { id: 63, category: "函数调用", question: "[[maybe_unused]] 属性作用？", options: ["标记必须使用", "忽略未使用警告", "延迟初始化", "优化提示"], correct: 1, explanation: "告诉编译器变量可能不使用" },
    { id: 64, category: "函数调用", question: "std::function vs 函数指针？", options: ["更快", "支持lambda和捕获", "更省内存", "更简洁"], correct: 1, explanation: "function可包装任何可调用对象" },
    { id: 65, category: "函数调用", question: "lambda 值捕获和引用捕获区别？", options: ["没有区别", "值拷贝，引用注意生命周期", "引用更快", "值捕获不能修改"], correct: 1, explanation: "值捕获会拷贝，引用需注意生命周期" },
    { id: 66, category: "C++新特性", question: "auto x = expr; 保留const和ref？", options: ["会保留", "不会，cv-ref被去除", "只保留const", "只保留引用"], correct: 1, explanation: "auto拷贝推导会去除const和引用" },
    { id: 67, category: "C++新特性", question: "decltype(expr) 保留精确类型？", options: ["不会", "会，包括ref和const", "只保留基本类型", "取决于表达式"], correct: 1, explanation: "decltype保留精确类型" },
    { id: 68, category: "C++新特性", question: "range-based for 本质是？", options: ["while循环", "begin/end的语法糖", "递归", "goto语句"], correct: 1, explanation: "是调用begin()和end()的语法糖" },
    { id: 69, category: "C++新特性", question: "nullptr vs NULL 优势？", options: ["更快", "类型安全，不当作0", "更省内存", "兼容性更好"], correct: 1, explanation: "nullptr是类型安全的" },
    { id: 70, category: "C++新特性", question: "enum class vs enum 优势？", options: ["更快", "强类型，作用域限定", "更省内存", "支持浮点"], correct: 1, explanation: "enum class是强类型枚举" },
    { id: 71, category: "C++新特性", question: "std::move 实际做了什么？", options: ["移动对象", "只是cast成右值引用", "复制对象", "删除对象"], correct: 1, explanation: "只是类型转换，真正移动在构造/赋值中" },
    { id: 72, category: "C++新特性", question: "std::forward 的作用？", options: ["前向声明", "完美转发，保留左右值", "循环遍历", "类型转换"], correct: 1, explanation: "用于完美转发，保留参数属性" },
    { id: 73, category: "C++新特性", question: "std::optional 未初始化访问？", options: ["返回默认值", "返回nullptr", "抛出异常", "未定义行为"], correct: 2, explanation: "访问空optional会抛出异常" },
    { id: 74, category: "C++新特性", question: "std::variant vs union 优势？", options: ["更省内存", "类型安全", "更快", "支持更多类型"], correct: 1, explanation: "variant是类型安全的union" },
    { id: 75, category: "C++新特性", question: "structured bindings 哪个版本？", options: ["C++11", "C++14", "C++17", "C++20"], correct: 2, explanation: "结构化绑定是C++17引入的" },
    { id: 76, category: "C++新特性", question: "if constexpr 的作用？", options: ["运行时条件", "编译期条件分支", "异常处理", "类型检查"], correct: 1, explanation: "if constexpr在编译期决定分支" },
    { id: 77, category: "C++新特性", question: "inline variables (C++17) 解决？", options: ["内联函数", "头文件变量可多次包含", "常量折叠", "模板实例化"], correct: 1, explanation: "inline变量允许头文件定义" },
    { id: 78, category: "C++新特性", question: "C++20 concept 用于？", options: ["面向对象", "模板约束", "内存管理", "并发编程"], correct: 1, explanation: "concept用于约束模板参数" },
    { id: 79, category: "C++新特性", question: "C++20 bit_cast vs reinterpret_cast？", options: ["更快", "类型安全，避免aliasing UB", "更通用", "支持更多类型"], correct: 1, explanation: "bit_cast提供安全的位级转换" },
    { id: 80, category: "C++新特性", question: "C++20 协程关键字？", options: ["async/await", "co_await/co_yield/co_return", "yield/resume", "coroutine/suspend"], correct: 1, explanation: "使用co_await、co_yield、co_return" },
    { id: 81, category: "模板系统", question: "SFINAE 是什么的缩写？", options: ["Standard Function...", "Substitution Failure Is Not An Error", "Static Function...", "Simple Format..."], correct: 1, explanation: "替换失败不是错误" },
    { id: 82, category: "模板系统", question: "模板偏特化和完全特化区别？", options: ["没有区别", "偏特化匹配部分参数", "偏特化更快", "完全特化只用于类"], correct: 1, explanation: "偏特化匹配部分模板参数" },
    { id: 83, category: "模板系统", question: "非类型模板参数可以是？", options: ["只能是int", "integral/pointer/reference等", "任意类型", "只能是类类型"], correct: 1, explanation: "可以是整型、指针、引用等" },
    { id: 84, category: "模板系统", question: "decltype(auto) vs auto 区别？", options: ["没有区别", "decltype(auto)保留ref/const", "auto更精确", "decltype(auto)更快"], correct: 1, explanation: "decltype(auto)保留精确类型" },
    { id: 85, category: "模板系统", question: "T&& 在模板中可能推导成？", options: ["只能是右值引用", "可能左值或右值引用", "只能是左值引用", "会编译错误"], correct: 1, explanation: "T&&是转发引用，可推导为左值或右值" },
    { id: 86, category: "模板系统", question: "sizeof...(Args) 的作用？", options: ["求参数总字节数", "求参数包数量", "求最大参数大小", "语法错误"], correct: 1, explanation: "返回参数包中的参数数量" },
    { id: 87, category: "模板系统", question: "fold expression 哪个版本？", options: ["C++11", "C++14", "C++17", "C++20"], correct: 2, explanation: "折叠表达式是C++17引入的" },
    { id: 88, category: "模板系统", question: "variadic templates 允许？", options: ["可变返回类型", "可变数量模板参数", "可变函数名", "可变作用域"], correct: 1, explanation: "允许接受任意数量的模板参数" },
    { id: 89, category: "模板系统", question: "std::enable_if 的作用？", options: ["启用函数", "SFINAE控制模板选择", "启用优化", "启用异常"], correct: 1, explanation: "利用SFINAE有条件启用模板" },
    { id: 90, category: "模板系统", question: "以下哪个不是 type traits？", options: ["std::is_same", "std::is_base_of", "std::is_function", "std::is_allocated"], correct: 3, explanation: "std::is_allocated不存在" },
    { id: 91, category: "常见UB", question: "signed integer overflow 是？", options: ["定义为回绕", "未定义行为(UB)", "抛出异常", "返回最大值"], correct: 1, explanation: "有符号整数溢出是UB" },
    { id: 92, category: "常见UB", question: "访问已释放内存是？", options: ["返回0", "未定义行为(UB)", "抛出异常", "程序终止"], correct: 1, explanation: "use-after-free是UB" },
    { id: 93, category: "常见UB", question: "数组越界访问是？", options: ["返回默认值", "未定义行为(UB)", "抛出异常", "自动扩容"], correct: 1, explanation: "数组越界访问是UB" },
    { id: 94, category: "常见UB", question: "使用悬垂指针是？", options: ["返回NULL", "未定义行为(UB)", "编译错误", "抛出异常"], correct: 1, explanation: "悬垂指针使用是UB" },
    { id: 95, category: "常见UB", question: "违反 strict aliasing 是？", options: ["性能下降", "未定义行为(UB)", "编译警告", "类型转换"], correct: 1, explanation: "违反strict aliasing是UB" },
    { id: 96, category: "常见UB", question: "多线程 data race 是？", options: ["程序变慢", "未定义行为(UB)", "死锁", "结果不确定但定义明确"], correct: 1, explanation: "data race是UB" },
    { id: 97, category: "常见UB", question: "左移位数 >= 类型位宽是？", options: ["结果为0", "未定义行为(UB)", "循环移位", "编译错误"], correct: 1, explanation: "移位数>=位宽是UB" },
    { id: 98, category: "常见UB", question: "使用失效的迭代器是？", options: ["返回end()", "未定义行为(UB)", "抛出异常", "自动更新"], correct: 1, explanation: "使用失效迭代器是UB" },
    { id: 99, category: "常见UB", question: "返回局部对象指针是？", options: ["返回副本", "未定义行为(UB)", "编译错误", "返回NULL"], correct: 1, explanation: "返回局部对象指针/引用是UB" },
    { id: 100, category: "常见UB", question: "同一表达式多次修改变量（无序）？", options: ["从左到右求值", "未定义行为(UB)", "编译错误", "随机结果"], correct: 1, explanation: "如 i = i++ + ++i 是UB" }
];

function getRandomQuestions(count) {
    const shuffled = [...allQuestions].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, count);
}

// ==================== Game State ====================
let gameState = {
    questions: [],
    currentIndex: 0,
    score: 0,
    answers: [],
    totalQuestions: 20
};

// ==================== Font Scale Helper ====================
function getFontScale(width) {
    if (width < 400) return 1.4;
    if (width < 500) return 1.3;
    if (width < 600) return 1.2;
    if (width < 800) return 1.1;
    return 1.0;
}

// ==================== Boot Scene ====================
class BootScene extends Phaser.Scene {
    constructor() {
        super({ key: 'BootScene' });
    }

    create() {
        document.getElementById('loading').style.display = 'none';
        this.scene.start('MenuScene');
    }
}

// ==================== Menu Scene ====================
class MenuScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MenuScene' });
    }

    create() {
        const { width, height } = this.cameras.main;
        const s = getFontScale(width);
        this.createBackground();

        const title = this.add.text(width / 2, height * 0.12, 'C++ Trivials', {
            fontSize: `${Math.floor(48 * s)}px`,
            fontFamily: 'Arial Black, sans-serif',
            color: '#00d4ff',
            stroke: '#0066cc',
            strokeThickness: 3
        }).setOrigin(0.5);

        this.tweens.add({
            targets: title,
            alpha: 0.8,
            duration: 1500,
            yoyo: true,
            repeat: -1,
            ease: 'Sine.easeInOut'
        });

        this.add.text(width / 2, height * 0.22, 'Quiz Game', {
            fontSize: `${Math.floor(28 * s)}px`,
            fontFamily: 'Arial, sans-serif',
            color: '#ffffff'
        }).setOrigin(0.5);

        this.add.text(width / 2, height * 0.34, '100 C++ Knowledge Points\nRandom 20 Questions Per Game', {
            fontSize: `${Math.floor(18 * s)}px`,
            fontFamily: 'Arial, sans-serif',
            color: '#888888',
            align: 'center',
            lineSpacing: 8
        }).setOrigin(0.5);

        const categories = [
            'Types & Expressions', 'Memory Management',
            'STL Containers', 'Functions',
            'C++11-20 Features', 'Templates', 'Common UB'
        ];

        const startY = height * 0.48;
        const lineH = Math.floor(26 * s);
        categories.forEach((cat, i) => {
            this.add.text(width / 2, startY + i * lineH, cat, {
                fontSize: `${Math.floor(16 * s)}px`,
                fontFamily: 'Arial, sans-serif',
                color: '#4a9eff'
            }).setOrigin(0.5);
        });

        this.createButton(width / 2, height * 0.88, 'Start Game', s, () => this.startGame());
        this.createParticles();
    }

    createBackground() {
        const { width, height } = this.cameras.main;
        const graphics = this.add.graphics();
        for (let i = 0; i < height; i++) {
            const ratio = i / height;
            graphics.fillStyle(Phaser.Display.Color.GetColor(26 + ratio * 10, 26 + ratio * 15, 46 + ratio * 20));
            graphics.fillRect(0, i, width, 1);
        }
        for (let i = 0; i < 5; i++) {
            this.add.circle(Phaser.Math.Between(0, width), Phaser.Math.Between(0, height), Phaser.Math.Between(50, 150), 0x4a9eff, 0.03);
        }
    }

    createButton(x, y, text, s, callback) {
        const bw = Math.floor(200 * s), bh = Math.floor(50 * s);
        const btn = this.add.container(x, y);
        const bg = this.add.graphics();
        bg.fillStyle(0x4a9eff, 1);
        bg.fillRoundedRect(-bw/2, -bh/2, bw, bh, 12);
        const btnText = this.add.text(0, 0, text, {
            fontSize: `${Math.floor(22 * s)}px`,
            fontFamily: 'Arial, sans-serif',
            color: '#ffffff'
        }).setOrigin(0.5);
        btn.add([bg, btnText]);
        btn.setSize(bw, bh);
        btn.setInteractive({ useHandCursor: true });
        btn.on('pointerover', () => { bg.clear(); bg.fillStyle(0x6ab4ff, 1); bg.fillRoundedRect(-bw/2, -bh/2, bw, bh, 12); });
        btn.on('pointerout', () => { bg.clear(); bg.fillStyle(0x4a9eff, 1); bg.fillRoundedRect(-bw/2, -bh/2, bw, bh, 12); });
        btn.on('pointerdown', callback);
        return btn;
    }

    createParticles() {
        const { width, height } = this.cameras.main;
        for (let i = 0; i < 15; i++) {
            const p = this.add.circle(Phaser.Math.Between(0, width), Phaser.Math.Between(0, height), Phaser.Math.Between(2, 4), 0x4a9eff, 0.5);
            this.tweens.add({
                targets: p, y: p.y - Phaser.Math.Between(50, 150), alpha: 0,
                duration: Phaser.Math.Between(3000, 6000), repeat: -1,
                onRepeat: () => { p.x = Phaser.Math.Between(0, width); p.y = height + 20; p.alpha = 0.5; }
            });
        }
    }

    startGame() {
        gameState.questions = getRandomQuestions(20);
        gameState.currentIndex = 0;
        gameState.score = 0;
        gameState.answers = [];
        this.cameras.main.fadeOut(400, 0, 0, 0);
        this.time.delayedCall(400, () => this.scene.start('GameScene'));
    }
}

// ==================== Game Scene ====================
class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
        this.optionButtons = [];
        this.canAnswer = true;
    }

    create() {
        const { width, height } = this.cameras.main;
        this.s = getFontScale(width);
        this.cameras.main.fadeIn(400);
        this.createBackground();

        // Progress bar
        const barY = height * 0.03;
        const barH = Math.max(16, Math.floor(16 * this.s));
        this.progressBg = this.add.graphics();
        this.progressBg.fillStyle(0x333355, 1);
        this.progressBg.fillRoundedRect(20, barY, width - 40, barH, 8);
        this.progressBar = this.add.graphics();

        // Question number and score
        const infoY = barY + barH + 10;
        this.questionNumText = this.add.text(20, infoY, '', {
            fontSize: `${Math.floor(18 * this.s)}px`, fontFamily: 'Arial, sans-serif', color: '#888888'
        });
        this.scoreText = this.add.text(width - 20, infoY, '', {
            fontSize: `${Math.floor(18 * this.s)}px`, fontFamily: 'Arial, sans-serif', color: '#4a9eff'
        }).setOrigin(1, 0);

        // Category
        this.categoryText = this.add.text(width / 2, infoY + Math.floor(28 * this.s), '', {
            fontSize: `${Math.floor(16 * this.s)}px`, fontFamily: 'Arial, sans-serif', color: '#666666'
        }).setOrigin(0.5);

        // Question box
        const qBoxY = height * 0.15;
        const qBoxH = height * 0.22;
        this.questionBg = this.add.graphics();
        this.questionBg.fillStyle(0x252540, 0.9);
        this.questionBg.fillRoundedRect(15, qBoxY, width - 30, qBoxH, 12);

        this.questionText = this.add.text(width / 2, qBoxY + qBoxH / 2, '', {
            fontSize: `${Math.floor(20 * this.s)}px`,
            fontFamily: 'Arial, sans-serif',
            color: '#ffffff',
            wordWrap: { width: width - 50 },
            align: 'center',
            lineSpacing: 6
        }).setOrigin(0.5);

        this.createOptions();

        // Explanation
        const expY = height * 0.92;
        this.explanationContainer = this.add.container(width / 2, expY);
        this.explanationContainer.setVisible(false);
        const expBg = this.add.graphics();
        expBg.fillStyle(0x333355, 0.9);
        expBg.fillRoundedRect(-(width/2 - 15), -25, width - 30, 50, 8);
        this.explanationText = this.add.text(0, 0, '', {
            fontSize: `${Math.floor(16 * this.s)}px`,
            fontFamily: 'Arial, sans-serif',
            color: '#aaaaaa',
            wordWrap: { width: width - 60 },
            align: 'center'
        }).setOrigin(0.5);
        this.explanationContainer.add([expBg, this.explanationText]);

        this.showQuestion();
    }

    createBackground() {
        const { width, height } = this.cameras.main;
        const graphics = this.add.graphics();
        for (let i = 0; i < height; i++) {
            const ratio = i / height;
            graphics.fillStyle(Phaser.Display.Color.GetColor(26 + ratio * 10, 26 + ratio * 15, 46 + ratio * 20));
            graphics.fillRect(0, i, width, 1);
        }
    }

    createOptions() {
        const { width, height } = this.cameras.main;
        const startY = height * 0.40;
        const spacing = height * 0.125;
        const btnW = width - 30;
        const btnH = Math.floor(52 * this.s);
        this.optionButtons = [];

        for (let i = 0; i < 4; i++) {
            const y = startY + i * spacing;
            const container = this.add.container(width / 2, y);

            const bg = this.add.graphics();
            bg.fillStyle(0x2a2a4a, 1);
            bg.lineStyle(2, 0x4a9eff, 0.5);
            bg.fillRoundedRect(-btnW / 2, -btnH / 2, btnW, btnH, 10);
            bg.strokeRoundedRect(-btnW / 2, -btnH / 2, btnW, btnH, 10);

            const label = this.add.text(-btnW / 2 + 15, 0, String.fromCharCode(65 + i) + '.', {
                fontSize: `${Math.floor(20 * this.s)}px`, fontFamily: 'Arial Black, sans-serif', color: '#4a9eff'
            }).setOrigin(0, 0.5);

            const text = this.add.text(-btnW / 2 + 50, 0, '', {
                fontSize: `${Math.floor(18 * this.s)}px`,
                fontFamily: 'Arial, sans-serif',
                color: '#ffffff',
                wordWrap: { width: btnW - 70 }
            }).setOrigin(0, 0.5);

            container.add([bg, label, text]);
            container.setSize(btnW, btnH);
            container.setInteractive({ useHandCursor: true });
            container.bg = bg; container.text = text; container.label = label; container.index = i;
            container.btnW = btnW; container.btnH = btnH;

            container.on('pointerover', () => {
                if (!this.canAnswer) return;
                bg.clear(); bg.fillStyle(0x3a3a5a, 1); bg.lineStyle(2, 0x6ab4ff, 1);
                bg.fillRoundedRect(-btnW / 2, -btnH / 2, btnW, btnH, 10);
                bg.strokeRoundedRect(-btnW / 2, -btnH / 2, btnW, btnH, 10);
            });
            container.on('pointerout', () => {
                if (!this.canAnswer) return;
                bg.clear(); bg.fillStyle(0x2a2a4a, 1); bg.lineStyle(2, 0x4a9eff, 0.5);
                bg.fillRoundedRect(-btnW / 2, -btnH / 2, btnW, btnH, 10);
                bg.strokeRoundedRect(-btnW / 2, -btnH / 2, btnW, btnH, 10);
            });
            container.on('pointerdown', () => { if (this.canAnswer) this.selectAnswer(i); });

            this.optionButtons.push(container);
        }
    }

    showQuestion() {
        const { width, height } = this.cameras.main;
        const q = gameState.questions[gameState.currentIndex];
        const barY = height * 0.03;
        const barH = Math.max(16, Math.floor(16 * this.s));

        const progress = gameState.currentIndex / gameState.totalQuestions;
        this.progressBar.clear();
        this.progressBar.fillStyle(0x4a9eff, 1);
        if (progress > 0) this.progressBar.fillRoundedRect(20, barY, (width - 40) * progress, barH, 8);

        this.questionNumText.setText(`${gameState.currentIndex + 1}/${gameState.totalQuestions}`);
        this.scoreText.setText(`Score: ${gameState.score}`);
        this.categoryText.setText(q.category);
        this.questionText.setText(q.question);

        this.canAnswer = true;
        this.explanationContainer.setVisible(false);

        this.optionButtons.forEach((btn, i) => {
            btn.text.setText(q.options[i]);
            btn.setAlpha(1);
            const { btnW, btnH } = btn;
            btn.bg.clear(); btn.bg.fillStyle(0x2a2a4a, 1); btn.bg.lineStyle(2, 0x4a9eff, 0.5);
            btn.bg.fillRoundedRect(-btnW / 2, -btnH / 2, btnW, btnH, 10);
            btn.bg.strokeRoundedRect(-btnW / 2, -btnH / 2, btnW, btnH, 10);
            btn.label.setColor('#4a9eff');
            btn.text.setColor('#ffffff');

            btn.setAlpha(0);
            btn.x = width / 2 + 30;
            this.tweens.add({ targets: btn, alpha: 1, x: width / 2, duration: 250, delay: i * 60, ease: 'Back.easeOut' });
        });
    }

    selectAnswer(index) {
        this.canAnswer = false;
        const { width } = this.cameras.main;
        const q = gameState.questions[gameState.currentIndex];
        const isCorrect = index === q.correct;

        gameState.answers.push({ question: q, selected: index, correct: isCorrect });
        if (isCorrect) { gameState.score++; this.scoreText.setText(`Score: ${gameState.score}`); }

        this.optionButtons.forEach((btn, i) => {
            const { btnW, btnH } = btn;
            if (i === q.correct) {
                btn.bg.clear(); btn.bg.fillStyle(0x2a5a2a, 1); btn.bg.lineStyle(3, 0x4aff4a, 1);
                btn.bg.fillRoundedRect(-btnW / 2, -btnH / 2, btnW, btnH, 10);
                btn.bg.strokeRoundedRect(-btnW / 2, -btnH / 2, btnW, btnH, 10);
                btn.label.setColor('#4aff4a');
                if (isCorrect) this.createCorrectEffect(btn.x, btn.y);
            } else if (i === index && !isCorrect) {
                btn.bg.clear(); btn.bg.fillStyle(0x5a2a2a, 1); btn.bg.lineStyle(3, 0xff4a4a, 1);
                btn.bg.fillRoundedRect(-btnW / 2, -btnH / 2, btnW, btnH, 10);
                btn.bg.strokeRoundedRect(-btnW / 2, -btnH / 2, btnW, btnH, 10);
                btn.label.setColor('#ff4a4a'); btn.text.setColor('#ff8888');
                this.tweens.add({ targets: btn, x: btn.x + 8, duration: 40, yoyo: true, repeat: 3 });
            } else {
                btn.setAlpha(0.4);
            }
        });

        this.explanationText.setText(q.explanation);
        this.explanationContainer.setVisible(true);
        this.explanationContainer.setAlpha(0);
        this.tweens.add({ targets: this.explanationContainer, alpha: 1, duration: 250 });

        this.time.delayedCall(1800, () => this.nextQuestion());
    }

    createCorrectEffect(x, y) {
        for (let i = 0; i < 10; i++) {
            const angle = (i / 10) * Math.PI * 2;
            const p = this.add.circle(x, y, 5, 0x4aff4a);
            this.tweens.add({
                targets: p, x: x + Math.cos(angle) * 60, y: y + Math.sin(angle) * 30,
                alpha: 0, scale: 0, duration: 400, ease: 'Power2', onComplete: () => p.destroy()
            });
        }
    }

    nextQuestion() {
        gameState.currentIndex++;
        if (gameState.currentIndex >= gameState.totalQuestions) {
            this.cameras.main.fadeOut(400, 0, 0, 0);
            this.time.delayedCall(400, () => this.scene.start('ResultScene'));
        } else {
            const { width } = this.cameras.main;
            this.optionButtons.forEach((btn, i) => {
                this.tweens.add({
                    targets: btn, x: -150, alpha: 0, duration: 150, delay: i * 40,
                    onComplete: () => { if (i === 3) this.showQuestion(); }
                });
            });
        }
    }
}

// ==================== Result Scene ====================
class ResultScene extends Phaser.Scene {
    constructor() {
        super({ key: 'ResultScene' });
    }

    create() {
        const { width, height } = this.cameras.main;
        this.s = getFontScale(width);
        this.cameras.main.fadeIn(400);
        this.createBackground();

        const percentage = Math.round((gameState.score / gameState.totalQuestions) * 100);
        let title, titleColor;
        if (percentage >= 90) { title = 'Excellent!'; titleColor = '#4aff4a'; }
        else if (percentage >= 70) { title = 'Great Job!'; titleColor = '#4a9eff'; }
        else if (percentage >= 50) { title = 'Good Try!'; titleColor = '#ffaa4a'; }
        else { title = 'Keep Learning!'; titleColor = '#ff6a6a'; }

        this.add.text(width / 2, height * 0.12, title, {
            fontSize: `${Math.floor(40 * this.s)}px`, fontFamily: 'Arial Black, sans-serif', color: titleColor
        }).setOrigin(0.5);

        this.scoreDisplay = this.add.text(width / 2, height * 0.24, '0', {
            fontSize: `${Math.floor(60 * this.s)}px`, fontFamily: 'Arial Black, sans-serif', color: '#ffffff'
        }).setOrigin(0.5);

        this.add.text(width / 2, height * 0.32, `out of ${gameState.totalQuestions}`, {
            fontSize: `${Math.floor(22 * this.s)}px`, fontFamily: 'Arial, sans-serif', color: '#888888'
        }).setOrigin(0.5);

        let displayScore = 0;
        this.time.addEvent({
            delay: 40, repeat: gameState.score,
            callback: () => { displayScore++; this.scoreDisplay.setText(displayScore.toString()); }
        });

        this.createPercentageCircle(width / 2, height * 0.48, percentage);

        const correctCount = gameState.answers.filter(a => a.correct).length;
        const wrongCount = gameState.answers.filter(a => !a.correct).length;

        this.add.text(width / 2 - 60, height * 0.64, `Correct: ${correctCount}`, {
            fontSize: `${Math.floor(20 * this.s)}px`, fontFamily: 'Arial, sans-serif', color: '#4aff4a'
        }).setOrigin(0.5);
        this.add.text(width / 2 + 60, height * 0.64, `Wrong: ${wrongCount}`, {
            fontSize: `${Math.floor(20 * this.s)}px`, fontFamily: 'Arial, sans-serif', color: '#ff6a6a'
        }).setOrigin(0.5);

        const btnY = height * 0.78;
        this.createButton(width / 2 - 80, btnY, 'Again', () => {
            this.cameras.main.fadeOut(400);
            this.time.delayedCall(400, () => this.scene.start('MenuScene'));
        });
        this.createButton(width / 2 + 80, btnY, 'Review', () => this.showReview());

        if (percentage >= 70) this.createCelebration();
    }

    createBackground() {
        const { width, height } = this.cameras.main;
        const graphics = this.add.graphics();
        for (let i = 0; i < height; i++) {
            const ratio = i / height;
            graphics.fillStyle(Phaser.Display.Color.GetColor(26 + ratio * 10, 26 + ratio * 15, 46 + ratio * 20));
            graphics.fillRect(0, i, width, 1);
        }
    }

    createPercentageCircle(x, y, percentage) {
        const radius = Math.floor(50 * this.s);
        const bgCircle = this.add.graphics();
        bgCircle.lineStyle(8, 0x333355, 1);
        bgCircle.arc(x, y, radius, 0, Math.PI * 2);
        bgCircle.strokePath();

        const progressCircle = this.add.graphics();
        const color = percentage >= 70 ? 0x4aff4a : percentage >= 50 ? 0xffaa4a : 0xff6a6a;

        this.tweens.addCounter({
            from: -Math.PI / 2,
            to: -Math.PI / 2 + (percentage / 100) * Math.PI * 2,
            duration: 800,
            ease: 'Power2',
            onUpdate: (tween) => {
                progressCircle.clear();
                progressCircle.lineStyle(8, color, 1);
                progressCircle.beginPath();
                progressCircle.arc(x, y, radius, -Math.PI / 2, tween.getValue());
                progressCircle.strokePath();
            }
        });

        this.add.text(x, y, `${percentage}%`, {
            fontSize: `${Math.floor(24 * this.s)}px`, fontFamily: 'Arial Black, sans-serif', color: '#ffffff'
        }).setOrigin(0.5);
    }

    createButton(x, y, text, callback) {
        const bw = Math.floor(120 * this.s), bh = Math.floor(44 * this.s);
        const btn = this.add.container(x, y);
        const bg = this.add.graphics();
        bg.fillStyle(0x4a9eff, 1);
        bg.fillRoundedRect(-bw/2, -bh/2, bw, bh, 10);
        const btnText = this.add.text(0, 0, text, {
            fontSize: `${Math.floor(18 * this.s)}px`, fontFamily: 'Arial, sans-serif', color: '#ffffff'
        }).setOrigin(0.5);
        btn.add([bg, btnText]);
        btn.setSize(bw, bh);
        btn.setInteractive({ useHandCursor: true });
        btn.on('pointerover', () => { bg.clear(); bg.fillStyle(0x6ab4ff, 1); bg.fillRoundedRect(-bw/2, -bh/2, bw, bh, 10); });
        btn.on('pointerout', () => { bg.clear(); bg.fillStyle(0x4a9eff, 1); bg.fillRoundedRect(-bw/2, -bh/2, bw, bh, 10); });
        btn.on('pointerdown', callback);
        return btn;
    }

    createCelebration() {
        const { width, height } = this.cameras.main;
        const colors = [0x4aff4a, 0x4a9eff, 0xffaa4a, 0xff6aff, 0xffff4a];
        for (let i = 0; i < 20; i++) {
            const px = Phaser.Math.Between(0, width);
            const color = Phaser.Utils.Array.GetRandom(colors);
            const p = this.add.rectangle(px, -20, 6, 6, color);
            p.setRotation(Phaser.Math.DegToRad(45));
            this.tweens.add({
                targets: p, y: height + 50, x: px + Phaser.Math.Between(-80, 80),
                rotation: p.rotation + Math.PI * 2,
                duration: Phaser.Math.Between(1500, 3000),
                delay: Phaser.Math.Between(0, 1500), repeat: -1
            });
        }
    }

    showReview() {
        this.children.removeAll();
        const { width, height } = this.cameras.main;
        this.createBackground();

        this.add.text(width / 2, 25, 'Review', {
            fontSize: `${Math.floor(28 * this.s)}px`, fontFamily: 'Arial Black, sans-serif', color: '#4a9eff'
        }).setOrigin(0.5);

        let scrollY = 0;
        const itemH = Math.floor(100 * this.s);
        const contentHeight = gameState.answers.length * itemH + 80;
        const container = this.add.container(0, 55);

        gameState.answers.forEach((answer, i) => {
            const y = i * itemH;
            const isCorrect = answer.correct;

            const bg = this.add.graphics();
            bg.fillStyle(isCorrect ? 0x2a4a2a : 0x4a2a2a, 0.8);
            bg.fillRoundedRect(10, y, width - 20, itemH - 8, 8);
            container.add(bg);

            const status = isCorrect ? '\u2713' : '\u2717';
            const statusColor = isCorrect ? '#4aff4a' : '#ff6a6a';
            container.add(this.add.text(20, y + 8, `${i + 1}. ${status}`, {
                fontSize: `${Math.floor(18 * this.s)}px`, fontFamily: 'Arial Black, sans-serif', color: statusColor
            }));

            container.add(this.add.text(20, y + 32, answer.question.question, {
                fontSize: `${Math.floor(14 * this.s)}px`, fontFamily: 'Arial, sans-serif', color: '#ffffff',
                wordWrap: { width: width - 40 }
            }));

            const correctAnswer = answer.question.options[answer.question.correct];
            if (!isCorrect) {
                const yourAnswer = answer.question.options[answer.selected];
                container.add(this.add.text(20, y + 58, `Your: ${yourAnswer}`, {
                    fontSize: `${Math.floor(12 * this.s)}px`, fontFamily: 'Arial, sans-serif', color: '#ff8888'
                }));
                container.add(this.add.text(20, y + 76, `Correct: ${correctAnswer}`, {
                    fontSize: `${Math.floor(12 * this.s)}px`, fontFamily: 'Arial, sans-serif', color: '#88ff88'
                }));
            } else {
                container.add(this.add.text(20, y + 62, `Answer: ${correctAnswer}`, {
                    fontSize: `${Math.floor(12 * this.s)}px`, fontFamily: 'Arial, sans-serif', color: '#88ff88'
                }));
            }
        });

        this.input.on('wheel', (pointer, go, dx, dy) => {
            scrollY -= dy * 0.5;
            scrollY = Phaser.Math.Clamp(scrollY, -(contentHeight - height + 120), 0);
            container.y = 55 + scrollY;
        });

        // Touch scroll support
        let startY = 0, startScrollY = 0;
        this.input.on('pointerdown', (pointer) => { startY = pointer.y; startScrollY = scrollY; });
        this.input.on('pointermove', (pointer) => {
            if (pointer.isDown) {
                scrollY = startScrollY + (pointer.y - startY);
                scrollY = Phaser.Math.Clamp(scrollY, -(contentHeight - height + 120), 0);
                container.y = 55 + scrollY;
            }
        });

        this.createButton(width / 2, height - 35, 'Back', () => {
            this.cameras.main.fadeOut(400);
            this.time.delayedCall(400, () => this.scene.start('MenuScene'));
        });
    }
}

// ==================== Start Game ====================
const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    parent: 'game-container',
    backgroundColor: '#1a1a2e',
    scene: [BootScene, MenuScene, GameScene, ResultScene],
    scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH
    }
};

const game = new Phaser.Game(config);
    </script>
</body>
</html>
